{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.clone = clone;\nexports.addLast = addLast;\nexports.addFirst = addFirst;\nexports.removeLast = removeLast;\nexports.removeFirst = removeFirst;\nexports.insert = insert;\nexports.removeAt = removeAt;\nexports.replaceAt = replaceAt;\nexports.getIn = getIn;\nexports.set = set;\nexports.setIn = setIn;\nexports.update = update;\nexports.updateIn = updateIn;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.mergeIn = mergeIn;\nexports.omit = omit;\nexports.addDefaults = addDefaults;\n/*!\n * Timm\n *\n * Immutability helpers with fast reads and acceptable writes.\n *\n * @copyright Guillermo Grau Panea 2016\n * @license MIT\n */\n\nvar INVALID_ARGS = 'INVALID_ARGS'; // ===============================================\n// ### Helpers\n// ===============================================\n\nfunction throwStr(msg) {\n  throw new Error(msg);\n}\n\nfunction getKeysAndSymbols(obj) {\n  var keys = Object.keys(obj);\n\n  if (Object.getOwnPropertySymbols) {\n    return keys.concat(Object.getOwnPropertySymbols(obj));\n  }\n\n  return keys;\n}\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nfunction clone(obj) {\n  if (Array.isArray(obj)) return obj.slice();\n  var keys = getKeysAndSymbols(obj);\n  var out = {};\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    out[key] = obj[key];\n  }\n\n  return out;\n}\n\nfunction doMerge(fAddDefaults, fDeep, first) {\n  var out = first;\n  !(out != null) && throwStr(process.env.NODE_ENV !== 'production' ? 'At least one object should be provided to merge()' : INVALID_ARGS);\n  var fChanged = false;\n\n  for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    rest[_key - 3] = arguments[_key];\n  }\n\n  for (var idx = 0; idx < rest.length; idx++) {\n    var obj = rest[idx];\n    if (obj == null) continue;\n    var keys = getKeysAndSymbols(obj);\n    if (!keys.length) continue;\n\n    for (var j = 0; j <= keys.length; j++) {\n      var key = keys[j];\n      if (fAddDefaults && out[key] !== undefined) continue;\n      var nextVal = obj[key];\n\n      if (fDeep && isObject(out[key]) && isObject(nextVal)) {\n        nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);\n      }\n\n      if (nextVal === undefined || nextVal === out[key]) continue;\n\n      if (!fChanged) {\n        fChanged = true;\n        out = clone(out);\n      }\n\n      out[key] = nextVal;\n    }\n  }\n\n  return out;\n}\n\nfunction isObject(o) {\n  var type = typeof o === 'undefined' ? 'undefined' : _typeof(o);\n  return o != null && type === 'object';\n} // _deepFreeze = (obj) ->\n//   Object.freeze obj\n//   for key in Object.getOwnPropertyNames obj\n//     val = obj[key]\n//     if isObject(val) and not Object.isFrozen val\n//       _deepFreeze val\n//   obj\n// ===============================================\n// -- ### Arrays\n// ===============================================\n// -- #### addLast()\n// -- Returns a new array with an appended item or items.\n// --\n// -- Usage: `addLast<T>(array: Array<T>, val: Array<T>|T): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addLast(arr, 'c')\n// -- // ['a', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addLast(arr, ['c', 'd'])\n// -- // ['a', 'b', 'c', 'd']\n// -- ```\n// `array.concat(val)` also handles the scalar case,\n// but is apparently very slow\n\n\nfunction addLast(array, val) {\n  if (Array.isArray(val)) return array.concat(val);\n  return array.concat([val]);\n} // -- #### addFirst()\n// -- Returns a new array with a prepended item or items.\n// --\n// -- Usage: `addFirst<T>(array: Array<T>, val: Array<T>|T): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = addFirst(arr, 'c')\n// -- // ['c', 'a', 'b']\n// -- arr2 === arr\n// -- // false\n// -- arr3 = addFirst(arr, ['c', 'd'])\n// -- // ['c', 'd', 'a', 'b']\n// -- ```\n\n\nfunction addFirst(array, val) {\n  if (Array.isArray(val)) return val.concat(array);\n  return [val].concat(array);\n} // -- #### removeLast()\n// -- Returns a new array removing the last item.\n// --\n// -- Usage: `removeLast<T>(array: Array<T>): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeLast(arr)\n// -- // ['a']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeLast(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeLast(array) {\n  if (!array.length) return array;\n  return array.slice(0, array.length - 1);\n} // -- #### removeFirst()\n// -- Returns a new array removing the first item.\n// --\n// -- Usage: `removeFirst<T>(array: Array<T>): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b']\n// -- arr2 = removeFirst(arr)\n// -- // ['b']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- arr3 = []\n// -- removeFirst(arr3) === arr3\n// -- // true\n// -- ```\n\n\nfunction removeFirst(array) {\n  if (!array.length) return array;\n  return array.slice(1);\n} // -- #### insert()\n// -- Returns a new array obtained by inserting an item or items\n// -- at a specified index.\n// --\n// -- Usage: `insert<T>(array: Array<T>, idx: number, val: Array<T>|T): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = insert(arr, 1, 'd')\n// -- // ['a', 'd', 'b', 'c']\n// -- arr2 === arr\n// -- // false\n// -- insert(arr, 1, ['d', 'e'])\n// -- // ['a', 'd', 'e', 'b', 'c']\n// -- ```\n\n\nfunction insert(array, idx, val) {\n  return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));\n} // -- #### removeAt()\n// -- Returns a new array obtained by removing an item at\n// -- a specified index.\n// --\n// -- Usage: `removeAt<T>(array: Array<T>, idx: number): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = removeAt(arr, 1)\n// -- // ['a', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same array is returned if there are no changes:\n// -- removeAt(arr, 4) === arr\n// -- // true\n// -- ```\n\n\nfunction removeAt(array, idx) {\n  if (idx >= array.length || idx < 0) return array;\n  return array.slice(0, idx).concat(array.slice(idx + 1));\n} // -- #### replaceAt()\n// -- Returns a new array obtained by replacing an item at\n// -- a specified index. If the provided item is the same as\n// -- (*referentially equal to*) the previous item at that position,\n// -- the original array is returned.\n// --\n// -- Usage: `replaceAt<T>(array: Array<T>, idx: number, newItem: T): Array<T>`\n// --\n// -- ```js\n// -- arr = ['a', 'b', 'c']\n// -- arr2 = replaceAt(arr, 1, 'd')\n// -- // ['a', 'd', 'c']\n// -- arr2 === arr\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- replaceAt(arr, 1, 'b') === arr\n// -- // true\n// -- ```\n\n\nfunction replaceAt(array, idx, newItem) {\n  if (array[idx] === newItem) return array;\n  var len = array.length;\n  var result = Array(len);\n\n  for (var i = 0; i < len; i++) {\n    result[i] = array[i];\n  }\n\n  result[idx] = newItem;\n  return result;\n} // ===============================================\n// -- ### Collections (objects and arrays)\n// ===============================================\n// -- The following types are used throughout this section\n// -- ```js\n// -- type ArrayOrObject = Array<any>|Object;\n// -- type Key = number|string;\n// -- ```\n// -- #### getIn()\n// -- Returns a value from an object at a given path. Works with\n// -- nested arrays and objects. If the path does not exist, it returns\n// -- `undefined`.\n// --\n// -- Usage: `getIn(obj: ?ArrayOrObject, path: Array<Key>): any`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: ['a', 'b', 'c'] }\n// -- getIn(obj, ['d', 'd1'])\n// -- // 3\n// -- getIn(obj, ['e', 1])\n// -- // 'b'\n// -- ```\n\n\nfunction getIn(obj, path) {\n  !Array.isArray(path) && throwStr(process.env.NODE_ENV !== 'production' ? 'A path array should be provided when calling getIn()' : INVALID_ARGS);\n  if (obj == null) return undefined;\n  var ptr = obj;\n\n  for (var i = 0; i < path.length; i++) {\n    var key = path[i];\n    ptr = ptr != null ? ptr[key] : undefined;\n    if (ptr === undefined) return ptr;\n  }\n\n  return ptr;\n} // -- #### set()\n// -- Returns a new object with a modified attribute.\n// -- If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `set<T>(obj: ?T, key: Key, val: any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = set(obj, 'b', 5)\n// -- // { a: 1, b: 5, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- set(obj, 'b', 2) === obj\n// -- // true\n// -- ```\n\n\nfunction set(obj, key, val) {\n  var fallback = typeof key === 'number' ? [] : {};\n  var finalObj = obj == null ? fallback : obj;\n  if (finalObj[key] === val) return finalObj;\n  var obj2 = clone(finalObj);\n  obj2[key] = val;\n  return obj2;\n} // -- #### setIn()\n// -- Returns a new object with a modified **nested** attribute.\n// --\n// -- Notes:\n// --\n// -- * If the provided value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// -- * If the path does not exist, it will be created before setting\n// -- the new value.\n// --\n// -- Usage: `setIn<T: ArrayOrObject>(obj: T, path: Array<Key>, val: any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 = setIn(obj, ['d', 'd1'], 4)\n// -- // { a: 1, b: 2, d: { d1: 4, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj2 === obj\n// -- // false\n// -- obj2.d === obj.d\n// -- // false\n// -- obj2.e === obj.e\n// -- // true\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = setIn(obj, ['d', 'd1'], 3)\n// -- // { a: 1, b: 2, d: { d1: 3, d2: 4 }, e: { e1: 'foo', e2: 'bar' } }\n// -- obj3 === obj\n// -- // true\n// -- obj3.d === obj.d\n// -- // true\n// -- obj3.e === obj.e\n// -- // true\n// --\n// -- // ... unknown paths create intermediate keys. Numeric segments are treated as array indices:\n// -- setIn({ a: 3 }, ['unknown', 0, 'path'], 4)\n// -- // { a: 3, unknown: [{ path: 4 }] }\n// -- ```\n\n\nfunction doSetIn(obj, path, val, idx) {\n  var newValue = void 0;\n  var key = path[idx];\n\n  if (idx === path.length - 1) {\n    newValue = val;\n  } else {\n    var nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === 'number' ? [] : {};\n    newValue = doSetIn(nestedObj, path, val, idx + 1);\n  }\n\n  return set(obj, key, newValue);\n}\n\nfunction setIn(obj, path, val) {\n  if (!path.length) return val;\n  return doSetIn(obj, path, val, 0);\n} // -- #### update()\n// -- Returns a new object with a modified attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `update<T: ArrayOrObject>(obj: T, key: Key,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3 }\n// -- obj2 = update(obj, 'b', (val) => val + 1)\n// -- // { a: 1, b: 3, c: 3 }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- update(obj, 'b', (val) => val) === obj\n// -- // true\n// -- ```\n\n\nfunction update(obj, key, fnUpdate) {\n  var prevVal = obj == null ? undefined : obj[key];\n  var nextVal = fnUpdate(prevVal);\n  return set(obj, key, nextVal);\n} // -- #### updateIn()\n// -- Returns a new object with a modified **nested** attribute,\n// -- calculated via a user-provided callback based on the current value.\n// -- If the calculated value is the same as (*referentially equal to*)\n// -- the previous value, the original object is returned.\n// --\n// -- Usage: `updateIn<T: ArrayOrObject>(obj: T, path: Array<Key>,\n// -- fnUpdate: (prevValue: any) => any): T`\n// --\n// -- ```js\n// -- obj = { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj2 = updateIn(obj, ['d', 'd1'], (val) => val + 1)\n// -- // { a: 1, d: { d1: 4, d2: 4 } }\n// -- obj2 === obj\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- obj3 = updateIn(obj, ['d', 'd1'], (val) => val)\n// -- // { a: 1, d: { d1: 3, d2: 4 } }\n// -- obj3 === obj\n// -- // true\n// -- ```\n\n\nfunction updateIn(obj, path, fnUpdate) {\n  var prevVal = getIn(obj, path);\n  var nextVal = fnUpdate(prevVal);\n  return setIn(obj, path, nextVal);\n} // -- #### merge()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- Similar to `Object.assign()`, but immutable.\n// --\n// -- Usage:\n// --\n// -- * `merge(obj1: Object, obj2: ?Object): Object`\n// -- * `merge(obj1: Object, ...objects: Array<?Object>): Object`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5 }\n// -- obj3 = merge(obj1, obj2)\n// -- // { a: 1, b: 2, c: 4, d: 5 }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- merge(obj1, { c: 3 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction merge(a, b, c, d, e, f) {\n  for (var _len2 = arguments.length, rest = Array(_len2 > 6 ? _len2 - 6 : 0), _key2 = 6; _key2 < _len2; _key2++) {\n    rest[_key2 - 6] = arguments[_key2];\n  }\n\n  return rest.length ? doMerge.call.apply(doMerge, [null, false, false, a, b, c, d, e, f].concat(rest)) : doMerge(false, false, a, b, c, d, e, f);\n} // -- #### mergeDeep()\n// -- Returns a new object built as follows: the overlapping keys from the\n// -- second one overwrite the corresponding entries from the first one.\n// -- If both the first and second entries are objects they are merged recursively.\n// -- Similar to `Object.assign()`, but immutable, and deeply merging.\n// --\n// -- Usage:\n// --\n// -- * `mergeDeep(obj1: Object, obj2: ?Object): Object`\n// -- * `mergeDeep(obj1: Object, ...objects: Array<?Object>): Object`\n// --\n// -- The unmodified `obj1` is returned if `obj2` does not *provide something\n// -- new to* `obj1`, i.e. if either of the following\n// -- conditions are true:\n// --\n// -- * `obj2` is `null` or `undefined`\n// -- * `obj2` is an object, but it is empty\n// -- * All attributes of `obj2` are `undefined`\n// -- * All attributes of `obj2` are referentially equal to the\n// --   corresponding attributes of `obj1`\n// --\n// -- Note that `undefined` attributes in `obj2` do not modify the\n// -- corresponding attributes in `obj1`.\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: { a: 1 } }\n// -- obj2 = { b: 3, c: { b: 2 } }\n// -- obj3 = mergeDeep(obj1, obj2)\n// -- // { a: 1, b: 3, c: { a: 1, b: 2 }  }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeDeep(obj1, { c: { a: 1 } }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeDeep(a, b, c, d, e, f) {\n  for (var _len3 = arguments.length, rest = Array(_len3 > 6 ? _len3 - 6 : 0), _key3 = 6; _key3 < _len3; _key3++) {\n    rest[_key3 - 6] = arguments[_key3];\n  }\n\n  return rest.length ? doMerge.call.apply(doMerge, [null, false, true, a, b, c, d, e, f].concat(rest)) : doMerge(false, true, a, b, c, d, e, f);\n} // -- #### mergeIn()\n// -- Similar to `merge()`, but merging the value at a given nested path.\n// -- Note that the returned type is the same as that of the first argument.\n// --\n// -- Usage:\n// --\n// -- * `mergeIn<T: ArrayOrObject>(obj1: T, path: Array<Key>, obj2: ?Object): T`\n// -- * `mergeIn<T: ArrayOrObject>(obj1: T, path: Array<Key>,\n// -- ...objects: Array<?Object>): T`\n// --\n// -- ```js\n// -- obj1 = { a: 1, d: { b: { d1: 3, d2: 4 } } }\n// -- obj2 = { d3: 5 }\n// -- obj3 = mergeIn(obj1, ['d', 'b'], obj2)\n// -- // { a: 1, d: { b: { d1: 3, d2: 4, d3: 5 } } }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- mergeIn(obj1, ['d', 'b'], { d2: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction mergeIn(a, path, b, c, d, e, f) {\n  var prevVal = getIn(a, path);\n  if (prevVal == null) prevVal = {};\n  var nextVal = void 0;\n\n  for (var _len4 = arguments.length, rest = Array(_len4 > 7 ? _len4 - 7 : 0), _key4 = 7; _key4 < _len4; _key4++) {\n    rest[_key4 - 7] = arguments[_key4];\n  }\n\n  if (rest.length) {\n    nextVal = doMerge.call.apply(doMerge, [null, false, false, prevVal, b, c, d, e, f].concat(rest));\n  } else {\n    nextVal = doMerge(false, false, prevVal, b, c, d, e, f);\n  }\n\n  return setIn(a, path, nextVal);\n} // -- #### omit()\n// -- Returns an object excluding one or several attributes.\n// --\n// -- Usage: `omit(obj: Object, attrs: Array<string>|string): Object`\n//\n// -- ```js\n// -- obj = { a: 1, b: 2, c: 3, d: 4 }\n// -- omit(obj, 'a')\n// -- // { b: 2, c: 3, d: 4 }\n// -- omit(obj, ['b', 'c'])\n// -- // { a: 1, d: 4 }\n// --\n// -- // The same object is returned if there are no changes:\n// -- omit(obj, 'z') === obj1\n// -- // true\n// -- ```\n\n\nfunction omit(obj, attrs) {\n  var omitList = Array.isArray(attrs) ? attrs : [attrs];\n  var fDoSomething = false;\n\n  for (var i = 0; i < omitList.length; i++) {\n    if (hasOwnProperty.call(obj, omitList[i])) {\n      fDoSomething = true;\n      break;\n    }\n  }\n\n  if (!fDoSomething) return obj;\n  var out = {};\n  var keys = getKeysAndSymbols(obj);\n\n  for (var _i = 0; _i < keys.length; _i++) {\n    var key = keys[_i];\n    if (omitList.indexOf(key) >= 0) continue;\n    out[key] = obj[key];\n  }\n\n  return out;\n} // -- #### addDefaults()\n// -- Returns a new object built as follows: `undefined` keys in the first one\n// -- are filled in with the corresponding values from the second one\n// -- (even if they are `null`).\n// --\n// -- Usage:\n// --\n// -- * `addDefaults(obj: Object, defaults: Object): Object`\n// -- * `addDefaults(obj: Object, ...defaultObjects: Array<?Object>): Object`\n// --\n// -- ```js\n// -- obj1 = { a: 1, b: 2, c: 3 }\n// -- obj2 = { c: 4, d: 5, e: null }\n// -- obj3 = addDefaults(obj1, obj2)\n// -- // { a: 1, b: 2, c: 3, d: 5, e: null }\n// -- obj3 === obj1\n// -- // false\n// --\n// -- // The same object is returned if there are no changes:\n// -- addDefaults(obj1, { c: 4 }) === obj1\n// -- // true\n// -- ```\n\n\nfunction addDefaults(a, b, c, d, e, f) {\n  for (var _len5 = arguments.length, rest = Array(_len5 > 6 ? _len5 - 6 : 0), _key5 = 6; _key5 < _len5; _key5++) {\n    rest[_key5 - 6] = arguments[_key5];\n  }\n\n  return rest.length ? doMerge.call.apply(doMerge, [null, true, false, a, b, c, d, e, f].concat(rest)) : doMerge(true, false, a, b, c, d, e, f);\n} // ===============================================\n// ### Public API\n// ===============================================\n\n\nvar timm = {\n  clone: clone,\n  addLast: addLast,\n  addFirst: addFirst,\n  removeLast: removeLast,\n  removeFirst: removeFirst,\n  insert: insert,\n  removeAt: removeAt,\n  replaceAt: replaceAt,\n  getIn: getIn,\n  // eslint-disable-next-line object-shorthand\n  set: set,\n  // so that flow doesn't complain\n  setIn: setIn,\n  update: update,\n  updateIn: updateIn,\n  merge: merge,\n  mergeDeep: mergeDeep,\n  mergeIn: mergeIn,\n  omit: omit,\n  addDefaults: addDefaults\n};\nexports.default = timm;","map":null,"metadata":{},"sourceType":"script"}