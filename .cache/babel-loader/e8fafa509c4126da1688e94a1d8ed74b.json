{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _jsxFileName = \"/Users/brentvatne/coding/react-navigation-stack/src/views/StackView/StackViewLayout.tsx\";\nimport * as React from 'react';\nimport { Animated, StyleSheet, Platform, View, I18nManager, Easing, Dimensions } from 'react-native';\nimport { SceneView, StackActions, NavigationActions, NavigationProvider } from '@react-navigation/core';\nimport { withOrientation } from '@react-navigation/native';\nimport { ScreenContainer } from 'react-native-screens';\nimport { PanGestureHandler, State as GestureState } from 'react-native-gesture-handler';\nimport Card from './StackViewCard';\nimport Header from '../Header/Header';\nimport TransitionConfigs from './StackViewTransitionConfigs';\nimport HeaderStyleInterpolator from '../Header/HeaderStyleInterpolator';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport clamp from '../../utils/clamp';\nimport { supportsImprovedSpringAnimation } from '../../utils/ReactNativeFeatures';\nvar IPHONE_XS_HEIGHT = 812;\nvar IPHONE_XR_HEIGHT = 896;\n\nvar _Dimensions$get = Dimensions.get('window'),\n    WINDOW_WIDTH = _Dimensions$get.width,\n    WINDOW_HEIGHT = _Dimensions$get.height;\n\nvar IS_IPHONE_X = Platform.OS === 'ios' && !Platform.isPad && !Platform.isTVOS && (WINDOW_HEIGHT === IPHONE_XS_HEIGHT || WINDOW_WIDTH === IPHONE_XS_HEIGHT || WINDOW_HEIGHT === IPHONE_XR_HEIGHT || WINDOW_WIDTH === IPHONE_XR_HEIGHT);\nvar EaseInOut = Easing.inOut(Easing.ease);\nvar HEADER_LAYOUT_PRESET = ['center', 'left'];\nvar HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nvar HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\nvar USE_NATIVE_DRIVER = true;\n\nvar getDefaultHeaderHeight = function getDefaultHeaderHeight(isLandscape) {\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\n\nvar StackViewLayout = function (_React$Component) {\n  _inherits(StackViewLayout, _React$Component);\n\n  function StackViewLayout(props) {\n    var _this;\n\n    _classCallCheck(this, StackViewLayout);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StackViewLayout).call(this, props));\n    _this.immediateIndex = null;\n\n    _this.handleFloatingHeaderLayout = function (e) {\n      var height = e.nativeEvent.layout.height;\n\n      if (height !== _this.state.floatingHeaderHeight) {\n        _this.setState({\n          floatingHeaderHeight: height\n        });\n      }\n    };\n\n    _this.handlePanGestureStateChange = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n\n      if (nativeEvent.oldState === GestureState.ACTIVE) {\n        if (_this.positionSwitch.__getValue() === 1) {\n          return;\n        }\n\n        if (_this.isMotionVertical()) {\n          _this.handleReleaseVertical(nativeEvent);\n        } else {\n          _this.handleReleaseHorizontal(nativeEvent);\n        }\n      } else if (nativeEvent.state === GestureState.ACTIVE) {\n        _this.props.onGestureBegin && _this.props.onGestureBegin();\n\n        _this.positionSwitch.setValue(0);\n      }\n    };\n\n    _this.renderCard = function (scene) {\n      var _this$props = _this.props,\n          transitionProps = _this$props.transitionProps,\n          shadowEnabled = _this$props.shadowEnabled,\n          cardOverlayEnabled = _this$props.cardOverlayEnabled,\n          transparentCard = _this$props.transparentCard,\n          cardStyle = _this$props.cardStyle;\n      var _ref2 = _this.transitionConfig,\n          screenInterpolator = _ref2.screenInterpolator;\n      var style = screenInterpolator && screenInterpolator(_objectSpread({}, transitionProps, {\n        shadowEnabled: shadowEnabled,\n        cardOverlayEnabled: cardOverlayEnabled,\n        position: _this.position,\n        scene: scene\n      }));\n      var options = scene.descriptor.options;\n      var hasHeader = options.header !== null;\n\n      var headerMode = _this.getHeaderMode();\n\n      var floatingContainerStyle = StyleSheet.absoluteFill;\n\n      if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n        floatingContainerStyle = _objectSpread({}, Platform.select({\n          web: {},\n          default: StyleSheet.absoluteFillObject\n        }), {\n          paddingTop: _this.state.floatingHeaderHeight\n        });\n      }\n\n      return React.createElement(Card, _extends({}, transitionProps, {\n        key: \"card_\" + scene.key,\n        position: _this.position,\n        realPosition: transitionProps.position,\n        animatedStyle: style,\n        transparent: transparentCard,\n        style: [floatingContainerStyle, cardStyle],\n        scene: scene,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 971\n        }\n      }), _this.renderInnerScene(scene));\n    };\n\n    _this.panGestureRef = React.createRef();\n    _this.gestureX = new Animated.Value(0);\n    _this.gestureY = new Animated.Value(0);\n    _this.positionSwitch = new Animated.Value(1);\n\n    if (Animated.subtract) {\n      _this.gestureSwitch = Animated.subtract(1, _this.positionSwitch);\n    } else {\n      _this.gestureSwitch = Animated.add(1, Animated.multiply(-1, _this.positionSwitch));\n    }\n\n    _this.gestureEvent = Animated.event([{\n      nativeEvent: {\n        translationX: _this.gestureX,\n        translationY: _this.gestureY\n      }\n    }], {\n      useNativeDriver: USE_NATIVE_DRIVER\n    });\n    _this.state = {\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape)\n    };\n    return _this;\n  }\n\n  _createClass(StackViewLayout, [{\n    key: \"renderHeader\",\n    value: function renderHeader(scene, headerMode) {\n      var options = scene.descriptor.options;\n      var header = options.header;\n\n      if (__DEV__ && typeof header === 'string') {\n        throw new Error(\"Invalid header value: \\\"\" + header + \"\\\". The header option must be a valid React component or null, not a string.\");\n      }\n\n      if (header === null && headerMode === 'screen') {\n        return null;\n      }\n\n      if (React.isValidElement(header)) {\n        return header;\n      }\n\n      var renderHeader = header || function (props) {\n        return React.createElement(Header, _extends({}, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 222\n          }\n        }));\n      };\n\n      var _ref3 = this.transitionConfig,\n          headerLeftInterpolator = _ref3.headerLeftInterpolator,\n          headerTitleInterpolator = _ref3.headerTitleInterpolator,\n          headerRightInterpolator = _ref3.headerRightInterpolator,\n          headerBackgroundInterpolator = _ref3.headerBackgroundInterpolator;\n      var backgroundTransitionPresetInterpolator = this.getHeaderBackgroundTransitionPreset();\n\n      if (backgroundTransitionPresetInterpolator) {\n        headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n      }\n\n      var _this$props2 = this.props,\n          transitionProps = _this$props2.transitionProps,\n          passProps = _objectWithoutProperties(_this$props2, [\"transitionProps\"]);\n\n      return React.createElement(NavigationProvider, {\n        value: scene.descriptor.navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 239\n        }\n      }, renderHeader(_objectSpread({}, passProps, transitionProps, {\n        position: this.position,\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this.getHeaderTransitionPreset(),\n        layoutPreset: this.getHeaderLayoutPreset(),\n        backTitleVisible: this.getHeaderBackTitleVisible(),\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator,\n        backgroundInterpolator: headerBackgroundInterpolator\n      })));\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(resetToIndex, duration) {\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 6000,\n          damping: 100,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      } else {\n        Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      }\n    }\n  }, {\n    key: \"goBack\",\n    value: function goBack(backFromIndex, duration) {\n      var _this2 = this;\n\n      var _this$props$transitio = this.props.transitionProps,\n          navigation = _this$props$transitio.navigation,\n          position = _this$props$transitio.position,\n          scenes = _this$props$transitio.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this.immediateIndex = toValue;\n\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this2.immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n\n        if (backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n          navigation.dispatch(StackActions.completeTransition());\n        }\n      };\n\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 7000,\n          damping: 300,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      } else {\n        Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"prepareAnimated\",\n    value: function prepareAnimated() {\n      if (this.props === this.prevProps) {\n        return;\n      }\n\n      this.prevProps = this.props;\n      this.prepareGesture();\n      this.preparePosition();\n      this.prepareTransitionConfig();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.prepareAnimated();\n      var transitionProps = this.props.transitionProps;\n      var index = transitionProps.navigation.state.index,\n          scenes = transitionProps.scenes;\n      var headerMode = this.getHeaderMode();\n      var floatingHeader = null;\n\n      if (headerMode === 'float') {\n        var scene = transitionProps.scene;\n        floatingHeader = React.createElement(View, {\n          style: styles.floatingHeader,\n          pointerEvents: \"box-none\",\n          onLayout: this.handleFloatingHeaderLayout,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 361\n          }\n        }, this.renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(PanGestureHandler, _extends({}, this.gestureActivationCriteria(), {\n        ref: this.panGestureRef,\n        onGestureEvent: this.gestureEvent,\n        onHandlerStateChange: this.handlePanGestureStateChange,\n        enabled: index > 0 && this.isGestureEnabled(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 372\n        }\n      }), React.createElement(Animated.View, {\n        style: [styles.container, this.transitionConfig.containerStyle],\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 379\n        }\n      }, React.createElement(StackGestureContext.Provider, {\n        value: this.panGestureRef,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 382\n        }\n      }, React.createElement(ScreenContainer, {\n        style: styles.scenes,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 383\n        }\n      }, scenes.map(this.renderCard)), floatingHeader)));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevState = prevProps.transitionProps.navigation.state;\n      var state = this.props.transitionProps.navigation.state;\n\n      if (prevState.index !== state.index) {\n        this.maybeCancelGesture();\n      }\n    }\n  }, {\n    key: \"getGestureResponseDistance\",\n    value: function getGestureResponseDistance() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var _options$gestureRespo = options.gestureResponseDistance,\n          userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n      return this.isModal() ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n    }\n  }, {\n    key: \"gestureActivationCriteria\",\n    value: function gestureActivationCriteria() {\n      var layout = this.props.transitionProps.layout;\n      var gestureResponseDistance = this.getGestureResponseDistance();\n      var isMotionInverted = this.isMotionInverted();\n\n      if (this.isMotionVertical()) {\n        var height = layout.height.__getValue();\n\n        return {\n          maxDeltaX: 15,\n          minOffsetY: isMotionInverted ? -5 : 5,\n          hitSlop: isMotionInverted ? {\n            top: -height + gestureResponseDistance\n          } : {\n            bottom: -height + gestureResponseDistance\n          }\n        };\n      } else {\n        var width = layout.width.__getValue();\n\n        var hitSlop = -width + gestureResponseDistance;\n        return {\n          minOffsetX: isMotionInverted ? -5 : 5,\n          maxDeltaY: 20,\n          hitSlop: isMotionInverted ? {\n            left: hitSlop\n          } : {\n            right: hitSlop\n          }\n        };\n      }\n    }\n  }, {\n    key: \"isGestureEnabled\",\n    value: function isGestureEnabled() {\n      var gesturesEnabled = this.props.transitionProps.scene.descriptor.options.gesturesEnabled;\n      return typeof gesturesEnabled === 'boolean' ? gesturesEnabled : Platform.OS === 'ios';\n    }\n  }, {\n    key: \"isMotionVertical\",\n    value: function isMotionVertical() {\n      return this.isModal();\n    }\n  }, {\n    key: \"isModal\",\n    value: function isModal() {\n      return this.props.mode === 'modal';\n    }\n  }, {\n    key: \"isMotionInverted\",\n    value: function isMotionInverted() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var gestureDirection = options.gestureDirection;\n\n      if (this.isModal()) {\n        return gestureDirection === 'inverted';\n      } else {\n        return typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n      }\n    }\n  }, {\n    key: \"computeHorizontalGestureValue\",\n    value: function computeHorizontalGestureValue(_ref4) {\n      var translationX = _ref4.translationX;\n      var _this$props$transitio2 = this.props.transitionProps,\n          navigation = _this$props$transitio2.navigation,\n          layout = _this$props$transitio2.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.width.__getValue();\n\n      var x = this.isMotionInverted() ? -1 * translationX : translationX;\n      var value = index - x / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"computeVerticalGestureValue\",\n    value: function computeVerticalGestureValue(_ref5) {\n      var translationY = _ref5.translationY;\n      var _this$props$transitio3 = this.props.transitionProps,\n          navigation = _this$props$transitio3.navigation,\n          layout = _this$props$transitio3.layout;\n      var index = navigation.state.index;\n\n      var distance = layout.height.__getValue();\n\n      var y = this.isMotionInverted() ? -1 * translationY : translationY;\n      var value = index - y / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"maybeCancelGesture\",\n    value: function maybeCancelGesture() {\n      this.positionSwitch.setValue(1);\n    }\n  }, {\n    key: \"prepareGesture\",\n    value: function prepareGesture() {\n      if (!this.isGestureEnabled()) {\n        if (this.positionSwitch.__getValue() !== 1) {\n          this.positionSwitch.setValue(1);\n        }\n\n        this.gesturePosition = undefined;\n        return;\n      }\n\n      if (this.props.transitionProps.layout.width.__getValue() === 0 || this.props.transitionProps.layout.height.__getValue() === 0) {\n        return;\n      }\n\n      if (this.isMotionVertical()) {\n        this.prepareGestureVertical();\n      } else {\n        this.prepareGestureHorizontal();\n      }\n    }\n  }, {\n    key: \"prepareGestureHorizontal\",\n    value: function prepareGestureHorizontal() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this.isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureX, this.props.transitionProps.layout.width)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureX, this.props.transitionProps.layout.width))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"prepareGestureVertical\",\n    value: function prepareGestureVertical() {\n      var index = this.props.transitionProps.navigation.state.index;\n\n      if (this.isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureY, this.props.transitionProps.layout.height)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureY, this.props.transitionProps.layout.height))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"handleReleaseHorizontal\",\n    value: function handleReleaseHorizontal(nativeEvent) {\n      var _this$props$transitio4 = this.props.transitionProps,\n          navigation = _this$props$transitio4.navigation,\n          position = _this$props$transitio4.position,\n          layout = _this$props$transitio4.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this.immediateIndex == null ? index : this.immediateIndex;\n\n      var distance = layout.width.__getValue();\n\n      var movementDirection = this.isMotionInverted() ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationX;\n      var gestureVelocity = movementDirection * nativeEvent.velocityX;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = this.isMotionInverted() ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = this.isMotionInverted() ? movedDistance / velocity : (distance - movedDistance) / velocity;\n      var value = this.computeHorizontalGestureValue(nativeEvent);\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"handleReleaseVertical\",\n    value: function handleReleaseVertical(nativeEvent) {\n      var _this$props$transitio5 = this.props.transitionProps,\n          navigation = _this$props$transitio5.navigation,\n          position = _this$props$transitio5.position,\n          layout = _this$props$transitio5.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this.immediateIndex == null ? index : this.immediateIndex;\n\n      var distance = layout.height.__getValue();\n\n      var isMotionInverted = this.isMotionInverted();\n      var movementDirection = isMotionInverted ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationY;\n      var gestureVelocity = movementDirection * nativeEvent.velocityY;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = isMotionInverted ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = isMotionInverted ? movedDistance / velocity : (distance - movedDistance) / velocity;\n      var value = this.computeVerticalGestureValue(nativeEvent);\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n        return;\n      }\n\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n        return;\n      }\n\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"getHeaderMode\",\n    value: function getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n\n      if (Platform.OS === 'android' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n\n      return 'float';\n    }\n  }, {\n    key: \"getHeaderBackgroundTransitionPreset\",\n    value: function getHeaderBackgroundTransitionPreset() {\n      var headerBackgroundTransitionPreset = this.props.headerBackgroundTransitionPreset;\n\n      if (headerBackgroundTransitionPreset) {\n        if (HEADER_BACKGROUND_TRANSITION_PRESET.includes(headerBackgroundTransitionPreset)) {\n          if (headerBackgroundTransitionPreset === 'fade') {\n            return HeaderStyleInterpolator.forBackgroundWithFade;\n          } else if (headerBackgroundTransitionPreset === 'translate') {\n            return HeaderStyleInterpolator.forBackgroundWithTranslation;\n          } else if (headerBackgroundTransitionPreset === 'toggle') {\n            return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n          }\n        } else if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerBackgroundTransitionPreset - expected one of \" + HEADER_BACKGROUND_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerBackgroundTransitionPreset));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getHeaderLayoutPreset\",\n    value: function getHeaderLayoutPreset() {\n      var headerLayoutPreset = this.props.headerLayoutPreset;\n\n      if (headerLayoutPreset) {\n        if (__DEV__) {\n          if (this.getHeaderTransitionPreset() === 'uikit' && headerLayoutPreset === 'left' && Platform.OS === 'ios') {\n            console.warn(\"headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'\");\n          }\n        }\n\n        if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n          return headerLayoutPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerLayoutPreset - expected one of \" + HEADER_LAYOUT_PRESET.join(', ') + \" but received \" + JSON.stringify(headerLayoutPreset));\n        }\n      }\n\n      if (Platform.OS !== 'ios') {\n        return 'left';\n      } else {\n        return 'center';\n      }\n    }\n  }, {\n    key: \"getHeaderTransitionPreset\",\n    value: function getHeaderTransitionPreset() {\n      if (Platform.OS !== 'ios' || this.getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n\n      var headerTransitionPreset = this.props.headerTransitionPreset;\n\n      if (headerTransitionPreset) {\n        if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n          return headerTransitionPreset;\n        }\n\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerTransitionPreset - expected one of \" + HEADER_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerTransitionPreset));\n        }\n      }\n\n      return 'fade-in-place';\n    }\n  }, {\n    key: \"getHeaderBackTitleVisible\",\n    value: function getHeaderBackTitleVisible() {\n      var headerBackTitleVisible = this.props.headerBackTitleVisible;\n      var layoutPreset = this.getHeaderLayoutPreset();\n      var enabledByDefault = !(layoutPreset === 'left' || Platform.OS !== 'ios');\n      return typeof headerBackTitleVisible === 'boolean' ? headerBackTitleVisible : enabledByDefault;\n    }\n  }, {\n    key: \"renderInnerScene\",\n    value: function renderInnerScene(scene) {\n      var _scene$descriptor = scene.descriptor,\n          navigation = _scene$descriptor.navigation,\n          getComponent = _scene$descriptor.getComponent;\n      var SceneComponent = getComponent();\n      var screenProps = this.props.screenProps;\n      var headerMode = this.getHeaderMode();\n\n      if (headerMode === 'screen') {\n        return React.createElement(View, {\n          style: styles.container,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 886\n          }\n        }, React.createElement(View, {\n          style: styles.scenes,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 887\n          }\n        }, React.createElement(SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 888\n          }\n        })), this.renderHeader(scene, headerMode));\n      }\n\n      return React.createElement(SceneView, {\n        screenProps: screenProps,\n        navigation: navigation,\n        component: SceneComponent,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 899\n        }\n      });\n    }\n  }, {\n    key: \"prepareTransitionConfig\",\n    value: function prepareTransitionConfig() {\n      this.transitionConfig = TransitionConfigs.getTransitionConfig(this.props.transitionConfig, _objectSpread({}, this.props.transitionProps, {\n        position: this.position\n      }), this.props.lastTransitionProps, this.isModal());\n    }\n  }, {\n    key: \"preparePosition\",\n    value: function preparePosition() {\n      if (this.gesturePosition) {\n        this.position = Animated.add(Animated.multiply(this.props.transitionProps.position, this.positionSwitch), Animated.multiply(this.gesturePosition, this.gestureSwitch));\n      } else {\n        this.position = this.props.transitionProps.position;\n      }\n    }\n  }]);\n\n  return StackViewLayout;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse',\n    overflow: 'hidden'\n  },\n  scenes: {\n    flex: 1\n  },\n  floatingHeader: {\n    position: Platform.select({\n      default: 'absolute',\n      web: 'fixed'\n    }),\n    left: 0,\n    top: 0,\n    right: 0\n  }\n});\nexport default withOrientation(StackViewLayout);","map":null,"metadata":{},"sourceType":"module"}