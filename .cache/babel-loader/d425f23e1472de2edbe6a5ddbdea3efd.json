{"ast":null,"code":"// Apply LZW-compression to a string and return base64 compressed string.\nexport function zip(s) {\n  try {\n    var dict = {};\n    var data = (s + \"\").split(\"\");\n    var out = [];\n    var currChar;\n    var phrase = data[0];\n    var code = 256;\n\n    for (var i = 1; i < data.length; i++) {\n      currChar = data[i];\n\n      if (dict[phrase + currChar] != null) {\n        phrase += currChar;\n      } else {\n        out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\n        dict[phrase + currChar] = code;\n        code++;\n        phrase = currChar;\n      }\n    }\n\n    out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\n\n    for (var j = 0; j < out.length; j++) {\n      out[j] = String.fromCharCode(out[j]);\n    }\n\n    return utoa(out.join(\"\"));\n  } catch (e) {\n    console.log(\"Failed to zip string return empty string\", e);\n    return \"\";\n  }\n} // Decompress an LZW-encoded base64 string\n\nexport function unzip(base64ZippedString) {\n  try {\n    var s = atou(base64ZippedString);\n    var dict = {};\n    var data = (s + \"\").split(\"\");\n    var currChar = data[0];\n    var oldPhrase = currChar;\n    var out = [currChar];\n    var code = 256;\n    var phrase;\n\n    for (var i = 1; i < data.length; i++) {\n      var currCode = data[i].charCodeAt(0);\n\n      if (currCode < 256) {\n        phrase = data[i];\n      } else {\n        phrase = dict[currCode] ? dict[currCode] : oldPhrase + currChar;\n      }\n\n      out.push(phrase);\n      currChar = phrase.charAt(0);\n      dict[code] = oldPhrase + currChar;\n      code++;\n      oldPhrase = phrase;\n    }\n\n    return out.join(\"\");\n  } catch (e) {\n    console.log(\"Failed to unzip string return empty string\", e);\n    return \"\";\n  }\n} // ucs-2 string to base64 encoded ascii\n\nexport function utoa(str) {\n  return window.btoa(unescape(encodeURIComponent(str)));\n} // base64 encoded ascii to ucs-2 string\n\nexport function atou(str) {\n  return decodeURIComponent(escape(window.atob(str)));\n} // LZW-compress a string\n\nexport function lzw_encode(s) {\n  var dict = {};\n  var data = (s + \"\").split(\"\");\n  var out = [];\n  var currChar;\n  var phrase = data[0];\n  var code = 256;\n\n  for (var i = 1; i < data.length; i++) {\n    currChar = data[i];\n\n    if (dict[phrase + currChar] != null) {\n      phrase += currChar;\n    } else {\n      out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\n      dict[phrase + currChar] = code;\n      code++;\n      phrase = currChar;\n    }\n  }\n\n  out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\n\n  for (var i = 0; i < out.length; i++) {\n    out[i] = String.fromCharCode(out[i]);\n  }\n\n  return out.join(\"\");\n} // Decompress an LZW-encoded string\n\nexport function lzw_decode(s) {\n  var dict = {};\n  var data = (s + \"\").split(\"\");\n  var currChar = data[0];\n  var oldPhrase = currChar;\n  var out = [currChar];\n  var code = 256;\n  var phrase;\n\n  for (var i = 1; i < data.length; i++) {\n    var currCode = data[i].charCodeAt(0);\n\n    if (currCode < 256) {\n      phrase = data[i];\n    } else {\n      phrase = dict[currCode] ? dict[currCode] : oldPhrase + currChar;\n    }\n\n    out.push(phrase);\n    currChar = phrase.charAt(0);\n    dict[code] = oldPhrase + currChar;\n    code++;\n    oldPhrase = phrase;\n  }\n\n  return out.join(\"\");\n}\n/*\r\n\t@fliptopbox\r\n\t\r\n\tLZW Compression/Decompression for Strings\r\n\tImplementation of LZW algorithms from:\r\n\thttp://rosettacode.org/wiki/LZW_compression#JavaScript\r\n\tUsage:\r\n\tvar a = 'a very very long string to be squashed';\r\n\tvar b = a.compress(); // 'a veryāăąlong striċ to bečquashed'\r\n\tvar c = b.uncompress(); // 'a very very long string to be squashed'\r\n\tconsole.log(a === c); // True\r\n\tvar d = a.compress(true); // return as Array\r\n\tconsole.log(d); // [97, 32, 118 .... 101, 100] an Array of ASCII codes\r\n*/\n\nexport function compress(asArray) {\n  \"use strict\"; // Build the dictionary.\n\n  asArray = asArray === true;\n  var i,\n      dictionary = {},\n      uncompressed = this,\n      c,\n      wc,\n      w = \"\",\n      result = [],\n      ASCII = \"\",\n      dictSize = 256;\n\n  for (i = 0; i < 256; i += 1) {\n    dictionary[String.fromCharCode(i)] = i;\n  }\n\n  for (i = 0; i < uncompressed.length; i += 1) {\n    c = uncompressed.charAt(i);\n    wc = w + c; //Do not use dictionary[wc] because javascript arrays\n    //will return values for array['pop'], array['push'] etc\n    // if (dictionary[wc]) {\n\n    if (dictionary.hasOwnProperty(wc)) {\n      w = wc;\n    } else {\n      result.push(dictionary[w]);\n      ASCII += String.fromCharCode(dictionary[w]); // Add wc to the dictionary.\n\n      dictionary[wc] = dictSize++;\n      w = String(c);\n    }\n  } // Output the code for w.\n\n\n  if (w !== \"\") {\n    result.push(dictionary[w]);\n    ASCII += String.fromCharCode(dictionary[w]);\n  }\n\n  return asArray ? result : ASCII;\n}\nexport function decompress() {\n  \"use strict\"; // Build the dictionary.\n\n  var i,\n      tmp = [],\n      dictionary = [],\n      compressed = this,\n      w,\n      result,\n      k,\n      entry = \"\",\n      dictSize = 256;\n\n  for (i = 0; i < 256; i += 1) {\n    dictionary[i] = String.fromCharCode(i);\n  }\n\n  if (compressed && typeof compressed === \"string\") {\n    // convert string into Array.\n    for (i = 0; i < compressed.length; i += 1) {\n      tmp.push(compressed[i].charCodeAt(0));\n    }\n\n    compressed = tmp;\n    tmp = null;\n  }\n\n  w = String.fromCharCode(compressed[0]);\n  result = w;\n\n  for (i = 1; i < compressed.length; i += 1) {\n    k = compressed[i];\n\n    if (dictionary[k]) {\n      entry = dictionary[k];\n    } else {\n      if (k === dictSize) {\n        entry = w + w.charAt(0);\n      } else {\n        return null;\n      }\n    }\n\n    result += entry; // Add w+entry[0] to the dictionary.\n\n    dictionary[dictSize++] = w + entry.charAt(0);\n    w = entry;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["D:\\Projetos\\PPMTool-React-Client\\src\\Utils\\Zip.js"],"names":["zip","s","dict","data","split","out","currChar","phrase","code","i","length","push","charCodeAt","j","String","fromCharCode","utoa","join","e","console","log","unzip","base64ZippedString","atou","oldPhrase","currCode","charAt","str","window","btoa","unescape","encodeURIComponent","decodeURIComponent","escape","atob","lzw_encode","lzw_decode","compress","asArray","dictionary","uncompressed","c","wc","w","result","ASCII","dictSize","hasOwnProperty","decompress","tmp","compressed","k","entry"],"mappings":"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","sourcesContent":["// Apply LZW-compression to a string and return base64 compressed string.\r\nexport function zip(s) {\r\n  try {\r\n    var dict = {};\r\n    var data = (s + \"\").split(\"\");\r\n    var out = [];\r\n    var currChar;\r\n    var phrase = data[0];\r\n    var code = 256;\r\n    for (var i = 1; i < data.length; i++) {\r\n      currChar = data[i];\r\n      if (dict[phrase + currChar] != null) {\r\n        phrase += currChar;\r\n      } else {\r\n        out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\r\n        dict[phrase + currChar] = code;\r\n        code++;\r\n        phrase = currChar;\r\n      }\r\n    }\r\n    out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\r\n    for (var j = 0; j < out.length; j++) {\r\n      out[j] = String.fromCharCode(out[j]);\r\n    }\r\n    return utoa(out.join(\"\"));\r\n  } catch (e) {\r\n    console.log(\"Failed to zip string return empty string\", e);\r\n    return \"\";\r\n  }\r\n}\r\n\r\n// Decompress an LZW-encoded base64 string\r\nexport function unzip(base64ZippedString) {\r\n  try {\r\n    var s = atou(base64ZippedString);\r\n    var dict = {};\r\n    var data = (s + \"\").split(\"\");\r\n    var currChar = data[0];\r\n    var oldPhrase = currChar;\r\n    var out = [currChar];\r\n    var code = 256;\r\n    var phrase;\r\n    for (var i = 1; i < data.length; i++) {\r\n      var currCode = data[i].charCodeAt(0);\r\n      if (currCode < 256) {\r\n        phrase = data[i];\r\n      } else {\r\n        phrase = dict[currCode] ? dict[currCode] : oldPhrase + currChar;\r\n      }\r\n      out.push(phrase);\r\n      currChar = phrase.charAt(0);\r\n      dict[code] = oldPhrase + currChar;\r\n      code++;\r\n      oldPhrase = phrase;\r\n    }\r\n    return out.join(\"\");\r\n  } catch (e) {\r\n    console.log(\"Failed to unzip string return empty string\", e);\r\n    return \"\";\r\n  }\r\n}\r\n\r\n// ucs-2 string to base64 encoded ascii\r\nexport function utoa(str) {\r\n  return window.btoa(unescape(encodeURIComponent(str)));\r\n}\r\n// base64 encoded ascii to ucs-2 string\r\nexport function atou(str) {\r\n  return decodeURIComponent(escape(window.atob(str)));\r\n}\r\n\r\n// LZW-compress a string\r\nexport function lzw_encode(s) {\r\n  var dict = {};\r\n  var data = (s + \"\").split(\"\");\r\n  var out = [];\r\n  var currChar;\r\n  var phrase = data[0];\r\n  var code = 256;\r\n  for (var i = 1; i < data.length; i++) {\r\n    currChar = data[i];\r\n    if (dict[phrase + currChar] != null) {\r\n      phrase += currChar;\r\n    } else {\r\n      out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\r\n      dict[phrase + currChar] = code;\r\n      code++;\r\n      phrase = currChar;\r\n    }\r\n  }\r\n  out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));\r\n  for (var i = 0; i < out.length; i++) {\r\n    out[i] = String.fromCharCode(out[i]);\r\n  }\r\n  return out.join(\"\");\r\n}\r\n\r\n// Decompress an LZW-encoded string\r\nexport function lzw_decode(s) {\r\n  var dict = {};\r\n  var data = (s + \"\").split(\"\");\r\n  var currChar = data[0];\r\n  var oldPhrase = currChar;\r\n  var out = [currChar];\r\n  var code = 256;\r\n  var phrase;\r\n  for (var i = 1; i < data.length; i++) {\r\n    var currCode = data[i].charCodeAt(0);\r\n    if (currCode < 256) {\r\n      phrase = data[i];\r\n    } else {\r\n      phrase = dict[currCode] ? dict[currCode] : oldPhrase + currChar;\r\n    }\r\n    out.push(phrase);\r\n    currChar = phrase.charAt(0);\r\n    dict[code] = oldPhrase + currChar;\r\n    code++;\r\n    oldPhrase = phrase;\r\n  }\r\n  return out.join(\"\");\r\n}\r\n\r\n/*\r\n\t@fliptopbox\r\n\t\r\n\tLZW Compression/Decompression for Strings\r\n\tImplementation of LZW algorithms from:\r\n\thttp://rosettacode.org/wiki/LZW_compression#JavaScript\r\n\tUsage:\r\n\tvar a = 'a very very long string to be squashed';\r\n\tvar b = a.compress(); // 'a veryāăąlong striċ to bečquashed'\r\n\tvar c = b.uncompress(); // 'a very very long string to be squashed'\r\n\tconsole.log(a === c); // True\r\n\tvar d = a.compress(true); // return as Array\r\n\tconsole.log(d); // [97, 32, 118 .... 101, 100] an Array of ASCII codes\r\n*/\r\n\r\nexport function compress(asArray) {\r\n  \"use strict\";\r\n  // Build the dictionary.\r\n  asArray = asArray === true;\r\n  var i,\r\n    dictionary = {},\r\n    uncompressed = this,\r\n    c,\r\n    wc,\r\n    w = \"\",\r\n    result = [],\r\n    ASCII = \"\",\r\n    dictSize = 256;\r\n  for (i = 0; i < 256; i += 1) {\r\n    dictionary[String.fromCharCode(i)] = i;\r\n  }\r\n\r\n  for (i = 0; i < uncompressed.length; i += 1) {\r\n    c = uncompressed.charAt(i);\r\n    wc = w + c;\r\n    //Do not use dictionary[wc] because javascript arrays\r\n    //will return values for array['pop'], array['push'] etc\r\n    // if (dictionary[wc]) {\r\n    if (dictionary.hasOwnProperty(wc)) {\r\n      w = wc;\r\n    } else {\r\n      result.push(dictionary[w]);\r\n      ASCII += String.fromCharCode(dictionary[w]);\r\n      // Add wc to the dictionary.\r\n      dictionary[wc] = dictSize++;\r\n      w = String(c);\r\n    }\r\n  }\r\n\r\n  // Output the code for w.\r\n  if (w !== \"\") {\r\n    result.push(dictionary[w]);\r\n    ASCII += String.fromCharCode(dictionary[w]);\r\n  }\r\n  return asArray ? result : ASCII;\r\n}\r\n\r\nexport function decompress() {\r\n  \"use strict\";\r\n  // Build the dictionary.\r\n  var i,\r\n    tmp = [],\r\n    dictionary = [],\r\n    compressed = this,\r\n    w,\r\n    result,\r\n    k,\r\n    entry = \"\",\r\n    dictSize = 256;\r\n  for (i = 0; i < 256; i += 1) {\r\n    dictionary[i] = String.fromCharCode(i);\r\n  }\r\n\r\n  if (compressed && typeof compressed === \"string\") {\r\n    // convert string into Array.\r\n    for (i = 0; i < compressed.length; i += 1) {\r\n      tmp.push(compressed[i].charCodeAt(0));\r\n    }\r\n    compressed = tmp;\r\n    tmp = null;\r\n  }\r\n\r\n  w = String.fromCharCode(compressed[0]);\r\n  result = w;\r\n  for (i = 1; i < compressed.length; i += 1) {\r\n    k = compressed[i];\r\n    if (dictionary[k]) {\r\n      entry = dictionary[k];\r\n    } else {\r\n      if (k === dictSize) {\r\n        entry = w + w.charAt(0);\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    result += entry;\r\n\r\n    // Add w+entry[0] to the dictionary.\r\n    dictionary[dictSize++] = w + entry.charAt(0);\r\n\r\n    w = entry;\r\n  }\r\n  return result;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}