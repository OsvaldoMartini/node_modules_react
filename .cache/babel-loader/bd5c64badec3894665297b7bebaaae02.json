{"ast":null,"code":"// imported from ncp (this is temporary, will rewrite)\nvar fs = require('graceful-fs');\n\nvar path = require('path');\n\nvar utimes = require('../util/utimes');\n\nfunction ncp(source, dest, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  var basePath = process.cwd();\n  var currentPath = path.resolve(basePath, source);\n  var targetPath = path.resolve(basePath, dest);\n  var filter = options.filter;\n  var transform = options.transform;\n  var overwrite = options.overwrite; // If overwrite is undefined, use clobber, otherwise default to true:\n\n  if (overwrite === undefined) overwrite = options.clobber;\n  if (overwrite === undefined) overwrite = true;\n  var errorOnExist = options.errorOnExist;\n  var dereference = options.dereference;\n  var preserveTimestamps = options.preserveTimestamps === true;\n  var started = 0;\n  var finished = 0;\n  var running = 0;\n  var errored = false;\n  startCopy(currentPath);\n\n  function startCopy(source) {\n    started++;\n\n    if (filter) {\n      if (filter instanceof RegExp) {\n        console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function');\n\n        if (!filter.test(source)) {\n          return doneOne(true);\n        }\n      } else if (typeof filter === 'function') {\n        if (!filter(source, dest)) {\n          return doneOne(true);\n        }\n      }\n    }\n\n    return getStats(source);\n  }\n\n  function getStats(source) {\n    var stat = dereference ? fs.stat : fs.lstat;\n    running++;\n    stat(source, function (err, stats) {\n      if (err) return onError(err); // We need to get the mode from the stats object and preserve it.\n\n      var item = {\n        name: source,\n        mode: stats.mode,\n        mtime: stats.mtime,\n        // modified time\n        atime: stats.atime,\n        // access time\n        stats: stats // temporary\n\n      };\n\n      if (stats.isDirectory()) {\n        return onDir(item);\n      } else if (stats.isFile() || stats.isCharacterDevice() || stats.isBlockDevice()) {\n        return onFile(item);\n      } else if (stats.isSymbolicLink()) {\n        // Symlinks don't really need to know about the mode.\n        return onLink(source);\n      }\n    });\n  }\n\n  function onFile(file) {\n    var target = file.name.replace(currentPath, targetPath.replace('$', '$$$$')); // escapes '$' with '$$'\n\n    isWritable(target, function (writable) {\n      if (writable) {\n        copyFile(file, target);\n      } else {\n        if (overwrite) {\n          rmFile(target, function () {\n            copyFile(file, target);\n          });\n        } else if (errorOnExist) {\n          onError(new Error(target + ' already exists'));\n        } else {\n          doneOne();\n        }\n      }\n    });\n  }\n\n  function copyFile(file, target) {\n    var readStream = fs.createReadStream(file.name);\n    var writeStream = fs.createWriteStream(target, {\n      mode: file.mode\n    });\n    readStream.on('error', onError);\n    writeStream.on('error', onError);\n\n    if (transform) {\n      transform(readStream, writeStream, file);\n    } else {\n      writeStream.on('open', function () {\n        readStream.pipe(writeStream);\n      });\n    }\n\n    writeStream.once('close', function () {\n      fs.chmod(target, file.mode, function (err) {\n        if (err) return onError(err);\n\n        if (preserveTimestamps) {\n          utimes.utimesMillis(target, file.atime, file.mtime, function (err) {\n            if (err) return onError(err);\n            return doneOne();\n          });\n        } else {\n          doneOne();\n        }\n      });\n    });\n  }\n\n  function rmFile(file, done) {\n    fs.unlink(file, function (err) {\n      if (err) return onError(err);\n      return done();\n    });\n  }\n\n  function onDir(dir) {\n    var target = dir.name.replace(currentPath, targetPath.replace('$', '$$$$')); // escapes '$' with '$$'\n\n    isWritable(target, function (writable) {\n      if (writable) {\n        return mkDir(dir, target);\n      }\n\n      copyDir(dir.name);\n    });\n  }\n\n  function mkDir(dir, target) {\n    fs.mkdir(target, dir.mode, function (err) {\n      if (err) return onError(err); // despite setting mode in fs.mkdir, doesn't seem to work\n      // so we set it here.\n\n      fs.chmod(target, dir.mode, function (err) {\n        if (err) return onError(err);\n        copyDir(dir.name);\n      });\n    });\n  }\n\n  function copyDir(dir) {\n    fs.readdir(dir, function (err, items) {\n      if (err) return onError(err);\n      items.forEach(function (item) {\n        startCopy(path.join(dir, item));\n      });\n      return doneOne();\n    });\n  }\n\n  function onLink(link) {\n    var target = link.replace(currentPath, targetPath);\n    fs.readlink(link, function (err, resolvedPath) {\n      if (err) return onError(err);\n      checkLink(resolvedPath, target);\n    });\n  }\n\n  function checkLink(resolvedPath, target) {\n    if (dereference) {\n      resolvedPath = path.resolve(basePath, resolvedPath);\n    }\n\n    isWritable(target, function (writable) {\n      if (writable) {\n        return makeLink(resolvedPath, target);\n      }\n\n      fs.readlink(target, function (err, targetDest) {\n        if (err) return onError(err);\n\n        if (dereference) {\n          targetDest = path.resolve(basePath, targetDest);\n        }\n\n        if (targetDest === resolvedPath) {\n          return doneOne();\n        }\n\n        return rmFile(target, function () {\n          makeLink(resolvedPath, target);\n        });\n      });\n    });\n  }\n\n  function makeLink(linkPath, target) {\n    fs.symlink(linkPath, target, function (err) {\n      if (err) return onError(err);\n      return doneOne();\n    });\n  }\n\n  function isWritable(path, done) {\n    fs.lstat(path, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') return done(true);\n        return done(false);\n      }\n\n      return done(false);\n    });\n  }\n\n  function onError(err) {\n    // ensure callback is defined & called only once:\n    if (!errored && callback !== undefined) {\n      errored = true;\n      return callback(err);\n    }\n  }\n\n  function doneOne(skipped) {\n    if (!skipped) running--;\n    finished++;\n\n    if (started === finished && running === 0) {\n      if (callback !== undefined) {\n        return callback(null);\n      }\n    }\n  }\n}\n\nmodule.exports = ncp;","map":null,"metadata":{},"sourceType":"script"}