{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _reportUtils = require('./reportUtils'); // In-place\n// In case of split commands (or even split delimiters), joins all the pieces\n// at the starting node\n\n\nvar preprocessTemplate = function preprocessTemplate(template, options) {\n  var delimiter = options.cmdDelimiter;\n  var node = template;\n  var fCmd = false;\n  var openNode = null;\n  var idxDelimiter = 0;\n  var placeholderCmd = delimiter + 'CMD_NODE' + delimiter;\n\n  while (node != null) {\n    // Add `xml:space` attr `preserve` to `w:t` tags\n    if (!node._fTextNode && node._tag === 'w:t') {\n      node._attrs['xml:space'] = 'preserve';\n    } // Add a space if we reach a new `w:p` tag and there's an open node (hence, in a command)\n\n\n    if (!node._fTextNode && node._tag === 'w:p' && openNode) {\n      openNode._text += ' ';\n    } // Process text nodes inside `w:t` tags\n\n\n    if (node._fTextNode && node._parent && !node._parent._fTextNode && // Flow, don't complain\n    node._parent._tag === 'w:t') {\n      if (openNode == null) openNode = node;\n      var textIn = node._text;\n      node._text = '';\n\n      for (var i = 0; i < textIn.length; i++) {\n        var c = textIn[i]; // Matches the expected delimiter character\n\n        if (c === delimiter[idxDelimiter]) {\n          idxDelimiter += 1; // Finished matching delimiter? Then toggle `fCmd`,\n          // add a new `w:t` + text node (either before or after the delimiter),\n          // depending on the case\n\n          if (idxDelimiter === delimiter.length) {\n            fCmd = !fCmd;\n            var fNodesMatch = node === openNode;\n\n            if (fCmd && openNode._text.length) {\n              openNode = (0, _reportUtils.insertTextSiblingAfter)(openNode);\n              if (fNodesMatch) node = openNode;\n            }\n\n            openNode._text += delimiter;\n\n            if (!fCmd && i < textIn.length - 1) {\n              openNode = (0, _reportUtils.insertTextSiblingAfter)(openNode);\n              if (fNodesMatch) node = openNode;\n            }\n\n            idxDelimiter = 0;\n            if (!fCmd) openNode = node; // may switch open node to the current one\n          } // Doesn't match the delimiter, but we had some partial match\n\n        } else if (idxDelimiter) {\n          openNode._text += delimiter.slice(0, idxDelimiter);\n          idxDelimiter = 0;\n          if (!fCmd) openNode = node;\n          openNode._text += c; // General case\n        } else {\n          openNode._text += c;\n        }\n      } // Close the text node if nothing's pending\n\n\n      if (!fCmd && !idxDelimiter) openNode = null; // If text was present but not any more, add a placeholder, so that this node\n      // will be purged during report generation\n\n      if (textIn.length && !node._text.length) node._text = placeholderCmd;\n    } // Find next node to process\n\n\n    if (node._children.length) node = node._children[0];else {\n      var fFound = false;\n\n      while (node._parent != null) {\n        var nodeParent = node._parent;\n        var nextSibling = (0, _reportUtils.getNextSibling)(node);\n\n        if (nextSibling) {\n          fFound = true;\n          node = nextSibling;\n          break;\n        }\n\n        node = nodeParent;\n      }\n\n      if (!fFound) node = null;\n    }\n  }\n\n  return template;\n}; // ==========================================\n// Public API\n// ==========================================\n\n\nexports.default = preprocessTemplate;","map":null,"metadata":{},"sourceType":"script"}