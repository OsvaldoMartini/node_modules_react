{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.produceJsReport = exports.extractQuery = undefined;\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _reportUtils = require('./reportUtils');\n\nvar _jsSandbox = require('./jsSandbox');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar DEBUG = process.env.DEBUG_DOCX_TEMPLATES;\n/* eslint-disable no-param-reassign, no-constant-condition */\n\nvar log = DEBUG ? require('./debug').mainStory : null;\nvar chalk = DEBUG ? require('./debug').chalk : null; // Load the fs module (will only succeed in node)\n\nvar fs = void 0;\n\ntry {\n  fs = require('fs-extra'); // eslint-disable-line\n} catch (err) {\n  /* ignore */\n}\n\nvar gCntIf = 0; // Go through the document until the query string is found (normally at the beginning)\n\nvar extractQuery = function () {\n  var _ref = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee(template, options) {\n    var ctx, nodeIn, fFound, _parent, nextSibling, parent;\n\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            ctx = {\n              fCmd: false,\n              cmd: '',\n              fSeekQuery: true,\n              // ensure no command will be processed, except QUERY\n              query: null,\n              loops: [],\n              options: options\n            };\n            nodeIn = template;\n\n          case 2:\n            if (!true) {\n              _context.next = 30;\n              break;\n            }\n\n            if (!nodeIn._children.length) {\n              _context.next = 7;\n              break;\n            }\n\n            nodeIn = nodeIn._children[0];\n            _context.next = 20;\n            break;\n\n          case 7:\n            // Move sideways or up\n            fFound = false;\n\n          case 8:\n            if (!(nodeIn._parent != null)) {\n              _context.next = 18;\n              break;\n            }\n\n            _parent = nodeIn._parent;\n            nextSibling = (0, _reportUtils.getNextSibling)(nodeIn);\n\n            if (!nextSibling) {\n              _context.next = 15;\n              break;\n            }\n\n            nodeIn = nextSibling;\n            fFound = true;\n            return _context.abrupt('break', 18);\n\n          case 15:\n            nodeIn = _parent;\n            _context.next = 8;\n            break;\n\n          case 18:\n            if (fFound) {\n              _context.next = 20;\n              break;\n            }\n\n            return _context.abrupt('break', 30);\n\n          case 20:\n            if (nodeIn) {\n              _context.next = 22;\n              break;\n            }\n\n            return _context.abrupt('break', 30);\n\n          case 22:\n            parent = nodeIn._parent;\n\n            if (!(nodeIn._fTextNode && parent && !parent._fTextNode && // Flow, don't complain\n            parent._tag === 'w:t')) {\n              _context.next = 26;\n              break;\n            }\n\n            _context.next = 26;\n            return processText(null, nodeIn, ctx);\n\n          case 26:\n            if (!(ctx.query != null)) {\n              _context.next = 28;\n              break;\n            }\n\n            return _context.abrupt('break', 30);\n\n          case 28:\n            _context.next = 2;\n            break;\n\n          case 30:\n            return _context.abrupt('return', ctx.query);\n\n          case 31:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, undefined);\n  }));\n\n  return function extractQuery(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar produceJsReport = function () {\n  var _ref2 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee2(data, template, options) {\n    var out, ctx, nodeIn, nodeOut, move, deltaJump, curLoop, nextSibling, refNode, refNodeLevel, parent, tag, fRemoveNode, buffers, nodeOutParent, imgNode, _parent2, linkNode, _parent3, htmlNode, _parent4, _tag, newNode, _parent5, newNodeAsTextNode;\n\n    return _regenerator2.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            out = (0, _reportUtils.cloneNodeWithoutChildren)(template);\n            ctx = {\n              level: 1,\n              fCmd: false,\n              cmd: '',\n              fSeekQuery: false,\n              query: null,\n              buffers: {\n                'w:p': {\n                  text: '',\n                  cmds: '',\n                  fInsertedText: false\n                },\n                'w:tr': {\n                  text: '',\n                  cmds: '',\n                  fInsertedText: false\n                }\n              },\n              pendingImageNode: null,\n              imageId: 0,\n              images: {},\n              pendingLinkNode: null,\n              linkId: 0,\n              links: {},\n              pendingHtmlNode: null,\n              htmlId: 0,\n              htmls: {},\n              vars: {},\n              loops: [],\n              fJump: false,\n              shorthands: {},\n              options: options\n            };\n            nodeIn = template;\n            nodeOut = out;\n            move = void 0;\n            deltaJump = 0;\n\n          case 6:\n            if (!true) {\n              _context2.next = 75;\n              break;\n            } // eslint-disable-line no-constant-condition\n\n\n            curLoop = (0, _reportUtils.getCurLoop)(ctx);\n            nextSibling = void 0; // =============================================\n            // Move input node pointer\n            // =============================================\n\n            if (!ctx.fJump) {\n              _context2.next = 20;\n              break;\n            }\n\n            if (curLoop) {\n              _context2.next = 12;\n              break;\n            }\n\n            throw new Error('INTERNAL_ERROR');\n\n          case 12:\n            refNode = curLoop.refNode, refNodeLevel = curLoop.refNodeLevel; // DEBUG && log.debug(`Jumping to level ${refNodeLevel}...`,\n            //   { attach: cloneNodeForLogging(refNode) });\n\n            deltaJump = ctx.level - refNodeLevel;\n            nodeIn = refNode;\n            ctx.level = refNodeLevel;\n            ctx.fJump = false;\n            move = 'JUMP'; // Down (only if he haven't just moved up)\n\n            _context2.next = 37;\n            break;\n\n          case 20:\n            if (!(nodeIn._children.length && move !== 'UP')) {\n              _context2.next = 26;\n              break;\n            }\n\n            nodeIn = nodeIn._children[0];\n            ctx.level += 1;\n            move = 'DOWN'; // Sideways\n\n            _context2.next = 37;\n            break;\n\n          case 26:\n            if (!(nextSibling = (0, _reportUtils.getNextSibling)(nodeIn))) {\n              _context2.next = 31;\n              break;\n            }\n\n            nodeIn = nextSibling;\n            move = 'SIDE'; // Up\n\n            _context2.next = 37;\n            break;\n\n          case 31:\n            parent = nodeIn._parent;\n\n            if (!(parent == null)) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.abrupt('break', 75);\n\n          case 34:\n            nodeIn = parent;\n            ctx.level -= 1;\n            move = 'UP';\n\n          case 37:\n            // DEBUG && log.debug(`Next node [${chalk.green.bold(move)}]`,\n            //   { attach: cloneNodeForLogging(nodeIn) });\n            // =============================================\n            // Process input node\n            // =============================================\n            // Delete the last generated output node in several special cases\n            // --------------------------------------------------------------\n            if (move !== 'DOWN') {\n              tag = nodeOut._fTextNode ? null : nodeOut._tag;\n              fRemoveNode = false; // Delete last generated output node if we're skipping nodes due to an empty FOR loop\n\n              if ((tag === 'w:p' || tag === 'w:tbl' || tag === 'w:tr') && (0, _reportUtils.isLoopExploring)(ctx)) {\n                fRemoveNode = true; // Delete last generated output node if the user inserted a paragraph\n                // (or table row) with just a command\n              } else if (tag === 'w:p' || tag === 'w:tr') {\n                buffers = ctx.buffers[tag];\n                fRemoveNode = buffers.text === '' && buffers.cmds !== '' && !buffers.fInsertedText;\n              } // Execute removal, if needed. The node will no longer be part of the output, but\n              // the parent will be accessible from the child (so that we can still move up the tree)\n\n\n              if (fRemoveNode && nodeOut._parent != null) {\n                nodeOut._parent._children.pop();\n              }\n            } // Handle an UP movement\n            // ---------------------\n\n\n            if (!(move === 'UP')) {\n              _context2.next = 48;\n              break;\n            } // Loop exploring? Update the reference node for the current loop\n\n\n            if ((0, _reportUtils.isLoopExploring)(ctx) && curLoop && // Flow, don't complain\n            nodeIn === curLoop.refNode._parent) {\n              curLoop.refNode = nodeIn;\n              curLoop.refNodeLevel -= 1; // DEBUG && log.debug(`Updated loop '${curLoop.varName}' refNode:`,\n              //   { attach: cloneNodeForLogging(nodeIn) });\n            }\n\n            nodeOutParent = nodeOut._parent;\n\n            if (!(nodeOutParent == null)) {\n              _context2.next = 43;\n              break;\n            }\n\n            throw new Error('INTERNAL_ERROR');\n\n          case 43:\n            // Flow-prevention\n            // Execute the move in the output tree\n            nodeOut = nodeOutParent; // If an image was generated, replace the parent `w:t` node with\n            // the image node\n\n            if (ctx.pendingImageNode && !nodeOut._fTextNode && // Flow-prevention\n            nodeOut._tag === 'w:t') {\n              imgNode = ctx.pendingImageNode;\n              _parent2 = nodeOut._parent;\n\n              if (_parent2) {\n                imgNode._parent = _parent2;\n\n                _parent2._children.pop();\n\n                _parent2._children.push(imgNode); // Prevent containing paragraph or table row from being removed\n\n\n                ctx.buffers['w:p'].fInsertedText = true;\n                ctx.buffers['w:tr'].fInsertedText = true;\n              }\n\n              ctx.pendingImageNode = null;\n            } // If a link was generated, replace the parent `w:r` node with\n            // the link node\n\n\n            if (ctx.pendingLinkNode && !nodeOut._fTextNode && // Flow-prevention\n            nodeOut._tag === 'w:r') {\n              linkNode = ctx.pendingLinkNode;\n              _parent3 = nodeOut._parent;\n\n              if (_parent3) {\n                linkNode._parent = _parent3;\n\n                _parent3._children.pop();\n\n                _parent3._children.push(linkNode); // Prevent containing paragraph or table row from being removed\n\n\n                ctx.buffers['w:p'].fInsertedText = true;\n                ctx.buffers['w:tr'].fInsertedText = true;\n              }\n\n              ctx.pendingLinkNode = null;\n            } // If a html page was generated, replace the parent `w:p` node with\n            // the html node\n\n\n            if (ctx.pendingHtmlNode && !nodeOut._fTextNode && // Flow-prevention\n            nodeOut._tag === 'w:p') {\n              htmlNode = ctx.pendingHtmlNode;\n              _parent4 = nodeOut._parent;\n\n              if (_parent4) {\n                htmlNode._parent = _parent4;\n\n                _parent4._children.pop();\n\n                _parent4._children.push(htmlNode); // Prevent containing paragraph or table row from being removed\n\n\n                ctx.buffers['w:p'].fInsertedText = true;\n                ctx.buffers['w:tr'].fInsertedText = true;\n              }\n\n              ctx.pendingHtmlNode = null;\n            } // `w:tc` nodes shouldn't be left with no `w:p` children; if that's the\n            // case, add an empty `w:p` inside\n\n\n            if (!nodeOut._fTextNode && // Flow-prevention\n            nodeOut._tag === 'w:tc' && !nodeOut._children.filter(function (o) {\n              return !o._fTextNode && o._tag === 'w:p';\n            }).length) {\n              nodeOut._children.push({\n                _parent: nodeOut,\n                _children: [],\n                _fTextNode: false,\n                _tag: 'w:p',\n                _attrs: {}\n              });\n            }\n\n          case 48:\n            if (!(move === 'DOWN' || move === 'SIDE')) {\n              _context2.next = 65;\n              break;\n            }\n\n            if (!(move === 'SIDE')) {\n              _context2.next = 53;\n              break;\n            }\n\n            if (!(nodeOut._parent == null)) {\n              _context2.next = 52;\n              break;\n            }\n\n            throw new Error('INTERNAL_ERROR');\n\n          case 52:\n            // Flow-prevention\n            nodeOut = nodeOut._parent;\n\n          case 53:\n            // Reset node buffers as needed if a `w:p` or `w:tr` is encountered\n            _tag = nodeIn._fTextNode ? null : nodeIn._tag;\n\n            if (_tag === 'w:p' || _tag === 'w:tr') {\n              ctx.buffers[_tag] = {\n                text: '',\n                cmds: '',\n                fInsertedText: false\n              };\n            } // Clone input node and append to output tree\n\n\n            newNode = (0, _reportUtils.cloneNodeWithoutChildren)(nodeIn);\n            newNode._parent = nodeOut;\n\n            nodeOut._children.push(newNode);\n\n            _parent5 = nodeIn._parent; // If it's a text node inside a w:t, process it\n\n            if (!(nodeIn._fTextNode && _parent5 && !_parent5._fTextNode && // Flow-prevention\n            _parent5._tag === 'w:t')) {\n              _context2.next = 64;\n              break;\n            }\n\n            newNodeAsTextNode = newNode;\n            _context2.next = 63;\n            return processText(data, nodeIn, ctx);\n\n          case 63:\n            newNodeAsTextNode._text = _context2.sent;\n\n          case 64:\n            // Execute the move in the output tree\n            nodeOut = newNode;\n\n          case 65:\n            if (!(move === 'JUMP')) {\n              _context2.next = 73;\n              break;\n            }\n\n          case 66:\n            if (!(deltaJump > 0)) {\n              _context2.next = 73;\n              break;\n            }\n\n            if (!(nodeOut._parent == null)) {\n              _context2.next = 69;\n              break;\n            }\n\n            throw new Error('INTERNAL_ERROR');\n\n          case 69:\n            // Flow-prevention\n            nodeOut = nodeOut._parent;\n            deltaJump -= 1;\n            _context2.next = 66;\n            break;\n\n          case 73:\n            _context2.next = 6;\n            break;\n\n          case 75:\n            return _context2.abrupt('return', {\n              report: out,\n              images: ctx.images,\n              links: ctx.links,\n              htmls: ctx.htmls\n            });\n\n          case 76:\n          case 'end':\n            return _context2.stop();\n        }\n      }\n    }, _callee2, undefined);\n  }));\n\n  return function produceJsReport(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar processText = function () {\n  var _ref3 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee3(data, node, ctx) {\n    var cmdDelimiter, text, segments, outText, idx, segment, cmdResultText;\n    return _regenerator2.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            cmdDelimiter = ctx.options.cmdDelimiter;\n            text = node._text;\n\n            if (!(text == null || text === '')) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt('return', '');\n\n          case 4:\n            segments = text.split(cmdDelimiter);\n            outText = '';\n            idx = 0;\n\n          case 7:\n            if (!(idx < segments.length)) {\n              _context3.next = 22;\n              break;\n            } // Include the separators in the `buffers` field (used for deleting paragraphs if appropriate)\n\n\n            if (idx > 0) appendTextToTagBuffers(cmdDelimiter, ctx, {\n              fCmd: true\n            }); // Append segment either to the `ctx.cmd` buffer (to be executed), if we are in \"command mode\",\n            // or to the output text\n\n            segment = segments[idx]; // DEBUG && log.debug(`Token: '${segment}' (${ctx.fCmd})`);\n\n            if (ctx.fCmd) ctx.cmd += segment;else if (!(0, _reportUtils.isLoopExploring)(ctx)) outText += segment;\n            appendTextToTagBuffers(segment, ctx, {\n              fCmd: ctx.fCmd\n            }); // If there are more segments, execute the command (if we are in \"command mode\"),\n            // and toggle \"command mode\"\n\n            if (!(idx < segments.length - 1)) {\n              _context3.next = 19;\n              break;\n            }\n\n            if (!ctx.fCmd) {\n              _context3.next = 18;\n              break;\n            }\n\n            _context3.next = 16;\n            return processCmd(data, node, ctx);\n\n          case 16:\n            cmdResultText = _context3.sent;\n\n            if (cmdResultText != null) {\n              outText += cmdResultText;\n              appendTextToTagBuffers(cmdResultText, ctx, {\n                fCmd: false,\n                fInsertedText: true\n              });\n            }\n\n          case 18:\n            ctx.fCmd = !ctx.fCmd;\n\n          case 19:\n            idx++;\n            _context3.next = 7;\n            break;\n\n          case 22:\n            return _context3.abrupt('return', outText);\n\n          case 23:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, undefined);\n  }));\n\n  return function processText(_x6, _x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // ==========================================\n// Command processor\n// ==========================================\n\n\nvar processCmd = function () {\n  var _ref4 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee4(data, node, ctx) {\n    var cmd, cmdNameMatch, cmdName, cmdRest, out, aliasMatch, aliasName, fullCmd, img, pars, html;\n    return _regenerator2.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            cmd = getCommand(ctx);\n            DEBUG && log.debug('Processing cmd: ' + chalk.cyan.bold(cmd));\n            _context4.prev = 2; // Extract command name\n\n            cmdNameMatch = /^(\\S+)\\s*/.exec(cmd);\n            cmdName = void 0;\n            cmdRest = '';\n\n            if (cmdNameMatch != null) {\n              cmdName = cmdNameMatch[1].toUpperCase();\n              cmdRest = cmd.slice(cmdName.length).trim();\n            } // Seeking query?\n\n\n            if (!ctx.fSeekQuery) {\n              _context4.next = 10;\n              break;\n            }\n\n            if (cmdName === 'QUERY') ctx.query = cmdRest;\n            return _context4.abrupt('return', null);\n\n          case 10:\n            // Process command\n            out = void 0;\n\n            if (!(cmdName === 'QUERY' || cmdName === 'CMD_NODE')) {\n              _context4.next = 14;\n              break;\n            }\n\n            _context4.next = 78;\n            break;\n\n          case 14:\n            if (!(cmdName === 'ALIAS')) {\n              _context4.next = 24;\n              break;\n            }\n\n            aliasMatch = /^(\\S+)\\s+(.+)/.exec(cmdRest);\n\n            if (aliasMatch) {\n              _context4.next = 18;\n              break;\n            }\n\n            throw new Error('Invalid ALIAS command: ' + cmd);\n\n          case 18:\n            aliasName = aliasMatch[1];\n            fullCmd = aliasMatch[2];\n            ctx.shorthands[aliasName] = fullCmd;\n            DEBUG && log.debug('Defined alias \\'' + aliasName + '\\' for: ' + fullCmd); // VAR <varName> <expression>\n            // } else if (cmdName === 'VAR') {\n            //   if (!isLoopExploring(ctx)) {\n            //     const varMatch = /^(\\S+)\\s+(.+)/.exec(cmdRest);\n            //     if (!varMatch) throw new Error(`Invalid VAR command: ${cmd}`);\n            //     const varName = varMatch[1];\n            //     const code = varMatch[2];\n            //     const varValue = await runUserJsAndGetString(data, code, ctx);\n            //     ctx.vars[varName] = varValue;\n            //     // DEBUG && log.debug(`${varName} is now: ${JSON.stringify(varValue)}`);\n            //   }\n            // FOR <varName> IN <expression>\n            // IF <expression>\n\n            _context4.next = 78;\n            break;\n\n          case 24:\n            if (!(cmdName === 'FOR' || cmdName === 'IF')) {\n              _context4.next = 30;\n              break;\n            }\n\n            _context4.next = 27;\n            return processForIf(data, node, ctx, cmd, cmdName, cmdRest);\n\n          case 27:\n            out = _context4.sent;\n            _context4.next = 78;\n            break;\n\n          case 30:\n            if (!(cmdName === 'END-FOR' || cmdName === 'END-IF')) {\n              _context4.next = 34;\n              break;\n            }\n\n            out = processEndForIf(data, node, ctx, cmd, cmdName, cmdRest); // INS <expression>\n\n            _context4.next = 78;\n            break;\n\n          case 34:\n            if (!(cmdName === 'INS')) {\n              _context4.next = 41;\n              break;\n            }\n\n            if ((0, _reportUtils.isLoopExploring)(ctx)) {\n              _context4.next = 39;\n              break;\n            }\n\n            _context4.next = 38;\n            return (0, _jsSandbox.runUserJsAndGetString)(data, cmdRest, ctx);\n\n          case 38:\n            out = _context4.sent;\n\n          case 39:\n            _context4.next = 78;\n            break;\n\n          case 41:\n            if (!(cmdName === 'EXEC')) {\n              _context4.next = 47;\n              break;\n            }\n\n            if ((0, _reportUtils.isLoopExploring)(ctx)) {\n              _context4.next = 45;\n              break;\n            }\n\n            _context4.next = 45;\n            return (0, _jsSandbox.runUserJsAndGetRaw)(data, cmdRest, ctx);\n\n          case 45:\n            _context4.next = 78;\n            break;\n\n          case 47:\n            if (!(cmdName === 'IMAGE')) {\n              _context4.next = 57;\n              break;\n            }\n\n            if ((0, _reportUtils.isLoopExploring)(ctx)) {\n              _context4.next = 55;\n              break;\n            }\n\n            _context4.next = 51;\n            return (0, _jsSandbox.runUserJsAndGetRaw)(data, cmdRest, ctx);\n\n          case 51:\n            img = _context4.sent;\n\n            if (!(img != null)) {\n              _context4.next = 55;\n              break;\n            }\n\n            _context4.next = 55;\n            return processImage(ctx, img);\n\n          case 55:\n            _context4.next = 78;\n            break;\n\n          case 57:\n            if (!(cmdName === 'LINK')) {\n              _context4.next = 67;\n              break;\n            }\n\n            if ((0, _reportUtils.isLoopExploring)(ctx)) {\n              _context4.next = 65;\n              break;\n            }\n\n            _context4.next = 61;\n            return (0, _jsSandbox.runUserJsAndGetRaw)(data, cmdRest, ctx);\n\n          case 61:\n            pars = _context4.sent;\n\n            if (!(pars != null)) {\n              _context4.next = 65;\n              break;\n            }\n\n            _context4.next = 65;\n            return processLink(ctx, pars);\n\n          case 65:\n            _context4.next = 78;\n            break;\n\n          case 67:\n            if (!(cmdName === 'HTML')) {\n              _context4.next = 77;\n              break;\n            }\n\n            if ((0, _reportUtils.isLoopExploring)(ctx)) {\n              _context4.next = 75;\n              break;\n            }\n\n            _context4.next = 71;\n            return (0, _jsSandbox.runUserJsAndGetRaw)(data, cmdRest, ctx);\n\n          case 71:\n            html = _context4.sent;\n\n            if (!(html != null)) {\n              _context4.next = 75;\n              break;\n            }\n\n            _context4.next = 75;\n            return processHtml(ctx, html);\n\n          case 75:\n            _context4.next = 78;\n            break;\n\n          case 77:\n            throw new Error('Invalid command syntax: \\'' + cmd + '\\'');\n\n          case 78:\n            return _context4.abrupt('return', out);\n\n          case 81:\n            _context4.prev = 81;\n            _context4.t0 = _context4['catch'](2);\n            throw new Error('Error executing command: ' + cmd + '\\n' + _context4.t0.message);\n\n          case 84:\n          case 'end':\n            return _context4.stop();\n        }\n      }\n    }, _callee4, undefined, [[2, 81]]);\n  }));\n\n  return function processCmd(_x9, _x10, _x11) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar getCommand = function getCommand(ctx) {\n  var cmd = ctx.cmd;\n\n  if (cmd[0] === '*') {\n    var aliasName = cmd.slice(1).trim();\n    if (!ctx.shorthands[aliasName]) throw new Error('Unknown alias');\n    cmd = ctx.shorthands[aliasName];\n    DEBUG && log.debug('Alias for: ' + cmd);\n  } else if (cmd[0] === '=') {\n    cmd = 'INS ' + cmd.slice(1).trim();\n  } else if (cmd[0] === '!') {\n    cmd = 'EXEC ' + cmd.slice(1).trim();\n  }\n\n  ctx.cmd = '';\n  return cmd.trim();\n}; // ==========================================\n// Individual commands\n// ==========================================\n\n\nvar processForIf = function () {\n  var _ref5 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee5(data, node, ctx, cmd, cmdName, cmdRest) {\n    var isIf, forMatch, varName, curLoop, parentLoopLevel, fParentIsExploring, loopOver, shouldRun;\n    return _regenerator2.default.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            isIf = cmdName === 'IF'; // Identify FOR/IF loop\n\n            forMatch = void 0;\n            varName = void 0;\n\n            if (!isIf) {\n              _context5.next = 8;\n              break;\n            }\n\n            if (node._ifName == null) {\n              node._ifName = '__if_' + gCntIf;\n              gCntIf += 1;\n            }\n\n            varName = node._ifName;\n            _context5.next = 12;\n            break;\n\n          case 8:\n            forMatch = /^(\\S+)\\s+IN\\s+(.+)/i.exec(cmdRest);\n\n            if (forMatch) {\n              _context5.next = 11;\n              break;\n            }\n\n            throw new Error('Invalid FOR command: ' + cmd);\n\n          case 11:\n            varName = forMatch[1];\n\n          case 12:\n            // New FOR? If not, discard\n            curLoop = (0, _reportUtils.getCurLoop)(ctx);\n\n            if (curLoop && curLoop.varName === varName) {\n              _context5.next = 34;\n              break;\n            }\n\n            parentLoopLevel = ctx.loops.length - 1;\n            fParentIsExploring = parentLoopLevel >= 0 && ctx.loops[parentLoopLevel].idx === -1;\n            loopOver = void 0;\n\n            if (!fParentIsExploring) {\n              _context5.next = 21;\n              break;\n            }\n\n            loopOver = [];\n            _context5.next = 33;\n            break;\n\n          case 21:\n            if (!isIf) {\n              _context5.next = 28;\n              break;\n            }\n\n            _context5.next = 24;\n            return (0, _jsSandbox.runUserJsAndGetRaw)(data, cmdRest, ctx);\n\n          case 24:\n            shouldRun = !!_context5.sent;\n            loopOver = shouldRun ? [1] : [];\n            _context5.next = 33;\n            break;\n\n          case 28:\n            if (forMatch) {\n              _context5.next = 30;\n              break;\n            }\n\n            throw new Error('Invalid FOR command: ' + cmd);\n\n          case 30:\n            _context5.next = 32;\n            return (0, _jsSandbox.runUserJsAndGetRaw)(data, forMatch[2], ctx);\n\n          case 32:\n            loopOver = _context5.sent;\n\n          case 33:\n            ctx.loops.push({\n              refNode: node,\n              refNodeLevel: ctx.level,\n              varName: varName,\n              loopOver: loopOver,\n              isIf: isIf,\n              // run through the loop once first, without outputting anything\n              // (if we don't do it like this, we could not run empty loops!)\n              idx: -1\n            });\n\n          case 34:\n            (0, _reportUtils.logLoop)(ctx.loops);\n            return _context5.abrupt('return', null);\n\n          case 36:\n          case 'end':\n            return _context5.stop();\n        }\n      }\n    }, _callee5, undefined);\n  }));\n\n  return function processForIf(_x12, _x13, _x14, _x15, _x16, _x17) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar processEndForIf = function processEndForIf(data, node, ctx, cmd, cmdName, cmdRest) {\n  var curLoop = (0, _reportUtils.getCurLoop)(ctx);\n  if (!curLoop) throw new Error('Invalid command: ' + cmd);\n  var isIf = cmdName === 'END-IF';\n  var varName = isIf ? curLoop.varName : cmdRest;\n  if (curLoop.varName !== varName) throw new Error('Invalid command: ' + cmd);\n  var loopOver = curLoop.loopOver,\n      idx = curLoop.idx;\n\n  var _getNextItem = getNextItem(loopOver, idx),\n      nextItem = _getNextItem.nextItem,\n      curIdx = _getNextItem.curIdx;\n\n  if (nextItem != null) {\n    // next iteration\n    ctx.vars[varName] = nextItem;\n    ctx.fJump = true;\n    curLoop.idx = curIdx;\n  } else {\n    // loop finished\n    ctx.loops.pop();\n  }\n\n  return null;\n};\n/* eslint-disable */\n\n\nvar processImage = function () {\n  var _ref6 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee6(ctx, imagePars) {\n    var cx, cy, id, relId, alt, node, pic, drawing;\n    return _regenerator2.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            cx = (imagePars.width * 360e3).toFixed(0);\n            cy = (imagePars.height * 360e3).toFixed(0);\n            ctx.imageId += 1;\n            id = String(ctx.imageId);\n            relId = 'img' + id;\n            _context6.next = 7;\n            return getImageData(imagePars);\n\n          case 7:\n            ctx.images[relId] = _context6.sent;\n            alt = imagePars.alt || 'desc';\n            node = _reportUtils.newNonTextNode;\n            pic = node('pic:pic', {\n              'xmlns:pic': 'http://schemas.openxmlformats.org/drawingml/2006/picture'\n            }, [node('pic:nvPicPr', {}, [node('pic:cNvPr', {\n              id: '0',\n              name: 'Picture ' + id,\n              descr: alt\n            }), node('pic:cNvPicPr', {}, [node('a:picLocks', {\n              noChangeAspect: '1',\n              noChangeArrowheads: '1'\n            })])]), node('pic:blipFill', {}, [node('a:blip', {\n              'r:embed': relId,\n              cstate: 'print'\n            }, [node('a:extLst', {}, [node('a:ext', {\n              uri: '{28A0092B-C50C-407E-A947-70E740481C1C}'\n            }, [node('a14:useLocalDpi', {\n              'xmlns:a14': 'http://schemas.microsoft.com/office/drawing/2010/main',\n              val: '0'\n            })])])]), node('a:srcRect'), node('a:stretch', {}, [node('a:fillRect')])]), node('pic:spPr', {\n              bwMode: 'auto'\n            }, [node('a:xfrm', {}, [node('a:off', {\n              x: '0',\n              y: '0'\n            }), node('a:ext', {\n              cx: cx,\n              cy: cy\n            })]), node('a:prstGeom', {\n              prst: 'rect'\n            }, [node('a:avLst')]), node('a:noFill'), node('a:ln', {}, [node('a:noFill')])])]);\n            drawing = node('w:drawing', {}, [node('wp:inline', {\n              distT: '0',\n              distB: '0',\n              distL: '0',\n              distR: '0'\n            }, [node('wp:extent', {\n              cx: cx,\n              cy: cy\n            }), node('wp:docPr', {\n              id: id,\n              name: 'Picture ' + id,\n              descr: alt\n            }), node('wp:cNvGraphicFramePr', {}, [node('a:graphicFrameLocks', {\n              'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main',\n              noChangeAspect: '1'\n            })]), node('a:graphic', {\n              'xmlns:a': 'http://schemas.openxmlformats.org/drawingml/2006/main'\n            }, [node('a:graphicData', {\n              uri: 'http://schemas.openxmlformats.org/drawingml/2006/picture'\n            }, [pic])])])]);\n            ctx.pendingImageNode = drawing;\n\n          case 13:\n          case 'end':\n            return _context6.stop();\n        }\n      }\n    }, _callee6, undefined);\n  }));\n\n  return function processImage(_x18, _x19) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar getImageData = function () {\n  var _ref7 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee7(imagePars) {\n    var data, extension, imgPath, buffer;\n    return _regenerator2.default.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            data = imagePars.data, extension = imagePars.extension;\n\n            if (!data) {\n              _context7.next = 5;\n              break;\n            }\n\n            if (extension) {\n              _context7.next = 4;\n              break;\n            }\n\n            throw new Error('If you return image `data`, make sure you return an extension as well!');\n\n          case 4:\n            return _context7.abrupt('return', {\n              extension: extension,\n              data: data\n            });\n\n          case 5:\n            imgPath = imagePars.path;\n\n            if (imgPath) {\n              _context7.next = 8;\n              break;\n            }\n\n            throw new Error('Specify either image `path` or `data`');\n\n          case 8:\n            if (fs) {\n              _context7.next = 10;\n              break;\n            }\n\n            throw new Error('Cannot read image from file in the browser');\n\n          case 10:\n            _context7.next = 12;\n            return fs.readFile(imgPath);\n\n          case 12:\n            buffer = _context7.sent;\n            return _context7.abrupt('return', {\n              extension: _path2.default.extname(imgPath).toLowerCase(),\n              data: buffer\n            });\n\n          case 14:\n          case 'end':\n            return _context7.stop();\n        }\n      }\n    }, _callee7, undefined);\n  }));\n\n  return function getImageData(_x20) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar processLink = function () {\n  var _ref8 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee8(ctx, linkPars) {\n    var url, _linkPars$label, label, id, relId, node, link;\n\n    return _regenerator2.default.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            url = linkPars.url;\n            _linkPars$label = linkPars.label, label = _linkPars$label === undefined ? url : _linkPars$label;\n            ctx.linkId += 1;\n            id = String(ctx.linkId);\n            relId = 'link' + id;\n            ctx.links[relId] = {\n              url: url\n            };\n            node = _reportUtils.newNonTextNode;\n            link = node('w:hyperlink', {\n              'r:id': relId,\n              'w:history': '1'\n            }, [node('w:r', {}, [node('w:rPr', {}, [node('w:u', {\n              'w:val': 'single'\n            })]), node('w:t', {}, [(0, _reportUtils.newTextNode)(label)])])]);\n            ctx.pendingLinkNode = link;\n\n          case 9:\n          case 'end':\n            return _context8.stop();\n        }\n      }\n    }, _callee8, undefined);\n  }));\n\n  return function processLink(_x21, _x22) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\nvar processHtml = function () {\n  var _ref9 = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee9(ctx, data) {\n    var id, relId, node, html;\n    return _regenerator2.default.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            ctx.htmlId += 1;\n            id = String(ctx.htmlId);\n            relId = 'html' + id;\n            ctx.htmls[relId] = data;\n            node = _reportUtils.newNonTextNode;\n            html = node('w:altChunk', {\n              'r:id': relId\n            });\n            ctx.pendingHtmlNode = html;\n\n          case 7:\n          case 'end':\n            return _context9.stop();\n        }\n      }\n    }, _callee9, undefined);\n  }));\n\n  return function processHtml(_x23, _x24) {\n    return _ref9.apply(this, arguments);\n  };\n}(); // ==========================================\n// Helpers\n// ==========================================\n\n\nvar appendTextToTagBuffers = function appendTextToTagBuffers(text, ctx, options) {\n  if (ctx.fSeekQuery) return;\n  var fCmd = options.fCmd,\n      fInsertedText = options.fInsertedText;\n  var type = fCmd ? 'cmds' : 'text';\n  (0, _keys2.default)(ctx.buffers).forEach(function (key) {\n    var buf = ctx.buffers[key];\n    buf[type] += text;\n    if (fInsertedText) buf.fInsertedText = true;\n  });\n};\n\nvar getNextItem = function getNextItem(items, curIdx0) {\n  var nextItem = null;\n  var curIdx = curIdx0 != null ? curIdx0 : -1;\n\n  while (nextItem == null) {\n    curIdx += 1;\n    if (curIdx >= items.length) break;\n    var tempItem = items[curIdx];\n    if ((typeof tempItem === 'undefined' ? 'undefined' : (0, _typeof3.default)(tempItem)) === 'object' && tempItem.isDeleted) continue;\n    nextItem = tempItem;\n  }\n\n  return {\n    nextItem: nextItem,\n    curIdx: curIdx\n  };\n}; // ==========================================\n// Public API\n// ==========================================\n\n\nexports.extractQuery = extractQuery;\nexports.produceJsReport = produceJsReport;","map":null,"metadata":{},"sourceType":"script"}