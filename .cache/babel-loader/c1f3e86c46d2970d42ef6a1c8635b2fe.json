{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport invariant from './utils/invariant';\nvar StateUtils = {\n  get: function get(state, key) {\n    return state.routes.find(function (route) {\n      return route.key === key;\n    }) || null;\n  },\n  indexOf: function indexOf(state, key) {\n    return state.routes.findIndex(function (route) {\n      return route.key === key;\n    });\n  },\n  has: function has(state, key) {\n    return !!state.routes.some(function (route) {\n      return route.key === key;\n    });\n  },\n  push: function push(state, route) {\n    invariant(StateUtils.indexOf(state, route.key) === -1, 'should not push route with duplicated key %s', route.key);\n    var routes = state.routes.slice();\n    routes.push(route);\n    return _objectSpread({}, state, {\n      index: routes.length - 1,\n      routes: routes\n    });\n  },\n  pop: function pop(state) {\n    if (state.index <= 0) {\n      return state;\n    }\n\n    var routes = state.routes.slice(0, -1);\n    return _objectSpread({}, state, {\n      index: routes.length - 1,\n      routes: routes\n    });\n  },\n  jumpToIndex: function jumpToIndex(state, index) {\n    if (index === state.index) {\n      return state;\n    }\n\n    invariant(!!state.routes[index], 'invalid index %s to jump to', index);\n    return _objectSpread({}, state, {\n      index: index\n    });\n  },\n  jumpTo: function jumpTo(state, key) {\n    var index = StateUtils.indexOf(state, key);\n    return StateUtils.jumpToIndex(state, index);\n  },\n  back: function back(state) {\n    var index = state.index - 1;\n    var route = state.routes[index];\n    return route ? StateUtils.jumpToIndex(state, index) : state;\n  },\n  forward: function forward(state) {\n    var index = state.index + 1;\n    var route = state.routes[index];\n    return route ? StateUtils.jumpToIndex(state, index) : state;\n  },\n  replaceAndPrune: function replaceAndPrune(state, key, route) {\n    var index = StateUtils.indexOf(state, key);\n    var replaced = StateUtils.replaceAtIndex(state, index, route);\n    return _objectSpread({}, replaced, {\n      routes: replaced.routes.slice(0, index + 1)\n    });\n  },\n  replaceAt: function replaceAt(state, key, route) {\n    var preserveIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var index = StateUtils.indexOf(state, key);\n    var nextIndex = preserveIndex ? state.index : index;\n    var nextState = StateUtils.replaceAtIndex(state, index, route);\n    nextState.index = nextIndex;\n    return nextState;\n  },\n  replaceAtIndex: function replaceAtIndex(state, index, route) {\n    invariant(!!state.routes[index], 'invalid index %s for replacing route %s', index, route.key);\n\n    if (state.routes[index] === route && index === state.index) {\n      return state;\n    }\n\n    var routes = state.routes.slice();\n    routes[index] = route;\n    return _objectSpread({}, state, {\n      index: index,\n      routes: routes\n    });\n  },\n  reset: function reset(state, routes, index) {\n    invariant(routes.length && Array.isArray(routes), 'invalid routes to replace');\n    var nextIndex = index === undefined ? routes.length - 1 : index;\n\n    if (state.routes.length === routes.length && state.index === nextIndex) {\n      var compare = function compare(route, ii) {\n        return routes[ii] === route;\n      };\n\n      if (state.routes.every(compare)) {\n        return state;\n      }\n    }\n\n    invariant(!!routes[nextIndex], 'invalid index %s to reset', nextIndex);\n    return _objectSpread({}, state, {\n      index: nextIndex,\n      routes: routes\n    });\n  }\n};\nexport default StateUtils;","map":null,"metadata":{},"sourceType":"module"}