{"ast":null,"code":"var jsscompress = jsscompress || {};\n\n(function (jss) {\n  jss.exchange = function (a, i, j) {\n    var temp = a[i];\n    a[i] = a[j];\n    a[j] = temp;\n  };\n\n  var HauffNode = function (config) {\n    var config = config || {};\n\n    if (!config.left) {\n      config.left = null;\n    }\n\n    if (!config.right) {\n      config.right = null;\n    }\n\n    if (!config.freq) {\n      config.freq = 0;\n    }\n\n    if (!config.key) {\n      config.key = 0;\n    }\n\n    this.left = config.left;\n    this.right = config.right;\n    this.freq = config.freq;\n    this.key = config.key;\n  };\n\n  HauffNode.prototype.isLeaf = function () {\n    return this.left == null && this.right == null;\n  };\n\n  jss.HauffNode = HauffNode;\n\n  var Hauffman = function () {\n    this.root = null;\n  };\n\n  var QueueNode = function (item) {\n    this.value = item;\n    this.next = null;\n  };\n\n  jss.QueueNode = QueueNode;\n\n  var Queue = function () {\n    this.first = null;\n    this.last = null;\n    this.N = 0;\n  };\n\n  Queue.prototype.enqueue = function (item) {\n    var oldLast = this.last;\n    this.last = new jss.QueueNode(item);\n\n    if (oldLast != null) {\n      oldLast.next = this.last;\n    }\n\n    if (this.first == null) {\n      this.first = this.last;\n    }\n\n    this.N++;\n  };\n\n  Queue.prototype.dequeue = function () {\n    var oldFirst = this.first;\n\n    if (oldFirst == null) {\n      return undefined;\n    }\n\n    var item = oldFirst.value;\n    this.first = oldFirst.next;\n\n    if (this.first == null) {\n      this.last = null;\n    }\n\n    this.N--;\n    return item;\n  };\n\n  Queue.prototype.size = function () {\n    return this.N;\n  };\n\n  Queue.prototype.isEmpty = function () {\n    return this.N == 0;\n  };\n\n  jss.Queue = Queue;\n\n  var MinPQ = function (compare) {\n    this.s = [];\n    this.N = 0;\n\n    if (!compare) {\n      compare = function (a1, a2) {\n        return a1 - a2;\n      };\n    }\n\n    this.compare = compare;\n  };\n\n  MinPQ.prototype.enqueue = function (item) {\n    if (this.N + 1 >= this.s.length) {\n      this.resize(this.s.length * 2);\n    }\n\n    this.s[++this.N] = item;\n    this.swim(this.N);\n  };\n\n  MinPQ.prototype.delMin = function () {\n    if (this.N == 0) {\n      return undefined;\n    }\n\n    var item = this.s[1];\n    jss.exchange(this.s, 1, this.N--);\n    this.sink(1);\n\n    if (this.N == Math.floor(this.s.length / 4)) {\n      this.resize(Math.floor(this.s.length / 2));\n    }\n\n    return item;\n  };\n\n  MinPQ.prototype.sink = function (k) {\n    while (k * 2 <= this.N) {\n      var child = k * 2;\n\n      if (child < this.N && this.compare(this.s[child + 1], this.s[child]) < 0) {\n        child += 1;\n      }\n\n      if (this.compare(this.s[child], this.s[k]) < 0) {\n        jss.exchange(this.s, child, k);\n        k = child;\n      } else {\n        break;\n      }\n    }\n  };\n\n  MinPQ.prototype.size = function () {\n    return this.N;\n  };\n\n  MinPQ.prototype.isEmpty = function () {\n    return this.N == 0;\n  };\n\n  MinPQ.prototype.resize = function (len) {\n    var temp = [];\n\n    for (var i = 0; i < len; ++i) {\n      if (i < this.s.length) {\n        temp.push(this.s[i]);\n      } else {\n        temp.push(0);\n      }\n    }\n\n    this.s = temp;\n  };\n\n  MinPQ.prototype.swim = function (k) {\n    while (k > 1) {\n      parent = Math.floor(k / 2);\n\n      if (this.compare(this.s[k], this.s[parent]) < 0) {\n        jss.exchange(this.s, k, parent);\n        k = parent;\n      } else {\n        break;\n      }\n    }\n  };\n\n  jss.MinPQ = MinPQ;\n\n  Hauffman.prototype.readTrie = function (bitStream) {\n    var bit = bitStream.dequeue();\n\n    if (bit == 1) {\n      return new jss.HauffNode({\n        key: this.readChar(bitStream)\n      });\n    }\n\n    var left = this.readTrie(bitStream);\n    var right = this.readTrie(bitStream);\n    return new jss.HauffNode({\n      left: left,\n      right: right\n    });\n  };\n\n  Hauffman.prototype.readChar = function (bitStream) {\n    var cc = 0;\n\n    for (var i = 0; i < 8; ++i) {\n      var bit = 0;\n\n      if (!bitStream.isEmpty()) {\n        bit = bitStream.dequeue();\n      }\n\n      cc = cc * 2 + bit;\n    }\n\n    return cc;\n  };\n\n  Hauffman.prototype.writeChar = function (cc, bitStream) {\n    var temp = [];\n\n    for (var i = 0; i < 8; ++i) {\n      var bit = cc % 2;\n      temp.push(bit);\n      cc = Math.floor(cc / 2);\n    }\n\n    for (var i = temp.length - 1; i >= 0; --i) {\n      var bit = temp[i];\n      bitStream.enqueue(bit);\n    }\n  };\n\n  Hauffman.prototype.writeTrie = function (x, bitStream) {\n    if (x.isLeaf()) {\n      bitStream.enqueue(1);\n      this.writeChar(x.key, bitStream);\n      return;\n    }\n\n    bitStream.enqueue(0);\n    this.writeTrie(x.left, bitStream);\n    this.writeTrie(x.right, bitStream);\n  };\n\n  Hauffman.prototype.buildTrie = function (text) {\n    var freq = {};\n\n    for (var i = 0; i < text.length; ++i) {\n      var cc = text.charCodeAt(i);\n\n      if (cc in freq) {\n        freq[cc] += 1;\n      } else {\n        freq[cc] = 1;\n      }\n    }\n\n    var pq = new jss.MinPQ(function (node1, node2) {\n      return node1.freq - node2.freq;\n    });\n\n    for (var cc in freq) {\n      var count = freq[cc];\n      var node = new jss.HauffNode({\n        freq: count,\n        key: cc\n      });\n      pq.enqueue(node);\n    }\n\n    while (pq.size() > 1) {\n      var node1 = pq.delMin();\n      var node2 = pq.delMin();\n      var new_node = new jss.HauffNode({\n        left: node1,\n        right: node2,\n        freq: node1.freq + node2.freq\n      });\n      pq.enqueue(new_node);\n    }\n\n    return pq.delMin();\n  };\n\n  Hauffman.prototype.buildCode = function (x, s, code) {\n    if (x == null) {\n      return;\n    }\n\n    if (x.isLeaf()) {\n      code[x.key] = s;\n      return;\n    }\n\n    this.buildCode(x.left, s + \"0\", code);\n    this.buildCode(x.right, s + \"1\", code);\n  };\n\n  Hauffman.prototype.compressToBinary = function (text) {\n    var trie = this.buildTrie(text);\n    var code = {};\n    this.buildCode(trie, \"\", code);\n    var bitStream = new jss.Queue();\n    this.writeTrie(trie, bitStream);\n\n    for (var i = 0; i < text.length; ++i) {\n      var s = text.charCodeAt(i);\n      var cc = code[s];\n\n      for (var j = 0; j < cc.length; ++j) {\n        var bit = cc.charAt(j) == \"0\" ? 0 : 1;\n        bitStream.enqueue(bit);\n      }\n    }\n\n    return bitStream;\n  };\n\n  Hauffman.prototype.compress = function (text) {\n    var bitStream = this.compressToBinary(text);\n    var result = \"\";\n\n    while (!bitStream.isEmpty()) {\n      var cc = this.readChar(bitStream);\n      result = result + String.fromCharCode(cc);\n    }\n\n    return result;\n  };\n\n  Hauffman.prototype.decompressFromBinary = function (bitStream) {\n    var trie = this.readTrie(bitStream);\n    var code = {};\n    this.buildCode(trie, \"\", code);\n    var rcode = {};\n\n    for (var cc in code) {\n      rcode[code[cc]] = cc;\n    }\n\n    var text = \"\";\n    var key = \"\";\n\n    while (!bitStream.isEmpty()) {\n      var bit = bitStream.dequeue();\n\n      if (bit == 0) {\n        key = key + \"0\";\n      } else {\n        key = key + \"1\";\n      }\n\n      if (key in rcode) {\n        text = text + String.fromCharCode(rcode[key]);\n        key = \"\";\n      }\n    }\n\n    return text;\n  };\n\n  Hauffman.prototype.decompress = function (compressed) {\n    var bitStream = new jss.Queue();\n\n    for (var i = 0; i < compressed.length; ++i) {\n      var cc = compressed.charCodeAt(i);\n      this.writeChar(cc, bitStream);\n    }\n\n    return this.decompressFromBinary(bitStream);\n  };\n\n  jss.Hauffman = Hauffman;\n})(jsscompress);\n\nvar module = module || {};\n\nif (module) {\n  module.exports = jsscompress;\n}","map":null,"metadata":{},"sourceType":"script"}